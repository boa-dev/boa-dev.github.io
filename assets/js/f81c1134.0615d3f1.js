"use strict";
(self["webpackChunkboajs_dev"] = self["webpackChunkboajs_dev"] || []).push([[5749],{

/***/ 7735:
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"archive":{"blogPosts":[{"id":"/2025/06/15/temporal-impl-1","metadata":{"permalink":"/blog/2025/06/15/temporal-impl-1","source":"@site/blog/2025-06-15-temporal-impl-1.md","title":"Implementing Temporal, the new date/time API for JavaScript (and Rust!)","description":"A blog post about the temporal_rs Rust crate that implements JavaScript\'s Temporal API and how temporal_rs supports implementing Temporal in JavaScript engines.","date":"2025-06-15T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":12.24,"hasTruncateMarker":false,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Implementing Temporal, the new date/time API for JavaScript (and Rust!)","metadata":["temporal","temporal_rs","boa","date/time"],"description":"A blog post about the temporal_rs Rust crate that implements JavaScript\'s Temporal API and how temporal_rs supports implementing Temporal in JavaScript engines.","authors":"boa-dev"},"unlisted":false,"nextItem":{"title":"How ECMAScript Engines Optimize Your Variables","permalink":"/blog/2025/03/05/local-variables"}},"content":"Developing a JavaScript engine in Rust can seem like pretty daunting\\ntask to some. In order to demystify working on a feature and to go over\\nwhat we\'ve been working on implementing in Boa recently, we thought we\'d\\nwrite a post about implementing a JavaScript feature in Rust.\\n\\nMore specifically, this will be the first in a series of posts primarily\\nabout implementing the new date/time built-in: Temporal. We\'ll be going\\nover general lessons and interesting design choices we\'ve stumbled upon,\\nas well as the crates supporting that implementation.\\n\\nWhy should you care? Well, we are not only implementing Temporal for\\nJavaScript, but for Rust as well ... more on that in a bit.\\n\\nFirst, an aside!\\n\\n## What even is Temporal?\\n\\nTemporal is a modern API for handling date/time in a calendar and time\\nzone aware manner that includes nine objects with over 200+ methods.\\n\\nIn JavaScript, Temporal is a global built-in namespace object that\\nincludes each of these nine built-ins:\\n\\n- `Temporal.Now`\\n- `Temporal.PlainDate`\\n- `Temporal.PlainTime`\\n- `Temporal.PlainDateTime`\\n- `Temporal.ZonedDateTime`\\n- `Temporal.Duration`\\n- `Temporal.Instant`\\n- `Temporal.PlainYearMonth`\\n- `Temporal.PlainMonthDay`\\n\\nBut to be honest, this post isn\'t meant to give an overview of Temporal\\nand its general API. If Temporal is news to you and you are interested\\nin learning more, feel free to check out the phenomenal [MDN\\ndocumentation][mdn-temporal].\\n\\n## Back on track\\n\\nBeing Boa a JavaScript engine / interpreter, developing a correct\\nimplementation of the ECMAScript specification is our raison d\'Ãªtre.\\nThis, in consequence, makes implementing Temporal one of our most\\nimportant goals, since it represents roughly 7-8% of the current\\nconformance test suite (~4000 of the ~50,000 tests).\\n\\nWhen the PR of the first prototype of Temporal for Boa was submitted, a\\nfew things became evident:\\n\\n1. Date/Time is a complicated beast (duh)\\n2. There\'s room for optimization and improvement\\n3. This would be handy to have in Rust\\n\\nSo after the prototype was merged, we pulled it out of Boa\'s internal\\nbuiltins and externalized it into its own crate,\\n[`temporal_rs`][temporal-rs-repo], which landed behind an experimental\\nflag in Boa v0.18.\\n\\nAfter over a year and a half of development, Boa now sits at a\\nconformance of about 90% for Temporal (and growing), with the entire\\nimplementation being backed by `temporal_rs`.\\n\\nFor its part, `temporal_rs` is shaping up to be a proper Rust date/time\\nlibrary that can be used to implement Temporal in a JavaScript engine,\\nand even support general date/time use cases.\\n\\nLet\'s take a look at Temporal: it\'s JavaScript API, it\'s Rust API in\\n`temporal_rs`, and how `temporal_rs` supports implementing the\\nspecification.\\n\\n## Important core differences\\n\\nFirst, we need to talk about JavaScript values (`JsValue`) for a bit.\\nThis is functionally the core `any` value type of JavaScript. A\\n`JsValue` could be a number represented as a 64 bit floating point, a\\nstring, a boolean, or an object. Not only is it an `any`, but `JsValue`\\nis ultimately engine defined, with various implementations existing\\nacross engines.\\n\\nWhile this is handy for a dynamically typed language like JavaScript, it\\nis not ideal for implementing deep language specifications where an\\nobject or string may need to be cloned. Furthermore, it\'s just not great\\nfor an API in a typed language like Rust.\\n\\nTo work around this, we routinely use `FromStr` and a `FiniteF64` custom\\nprimitive to handle casting and constraining, respectively, which glues\\ndynamic types like `JsValue` with a typed API.\\n\\nFor instance, in Boa, we heavily lean into using the below patterns:\\n\\n```rust\\n// (Note: this is abridged for readability)\\n\\n// FiniteF64 usage\\nlet number: f64 = js_value.to_number(context)?;\\nlet finite_f64: FiniteF64 = FiniteF64::try_from(number)?;\\nlet year: i32 = finite_f64.as_integer_with_truncation::<i32>();\\n\\n// FromStr usage with `get_option`\\nlet options_obj: &JsObject = get_options_object(&js_value)?;\\nlet overflow: Option<ArithmeticOverflow> = get_option::<ArithmeticOverflow>(\\n    &options_obj,\\n    js_string!(\\"overflow\\"),\\n    context\\n)?;\\n```\\n\\nThis is the core glue between Boa and the `temporal_rs` API that we will\\nbe going over below.\\n\\n## Implementing constructors\\n\\nThere are a variety of ways to construct a core component like\\n`PlainDate`, and that stems from the core constructor for each of the\\ncore components: `new_with_overflow`.\\n\\n```rust\\nimpl PlainDate {\\n    pub fn new_with_overflow(year: i32, month: u8, day: u8, calendar: Calendar, overflow: ArithmeticOverflow) -> Result<Self> {\\n        // Create PlainDate\\n    }\\n}\\n```\\n\\nThis function supports the baseline construction of Temporal builtins,\\nwhich takes the usual year, month, day, alongside a calendar and also an\\noverflow option to constrain or reject based on whether the provided\\nvalues are in an expected range.\\n\\nHowever, we can better express this in Rust with common `try_` prefix\\nnotation.\\n\\n```rust\\nimpl PlainDate {\\n    pub fn new(year: i32, month: u8, day: u8, calendar: Calendar) -> Result<Self> {\\n        Self::new_with_overflow(year, month, day, calendar, ArithmeticOverflow::Constrain)\\n    }\\n\\n    pub fn try_new(year: i32, month: u8, day: u8, calendar: Calendar) -> Result<Self> {\\n        Self::new_with_overflow(year, month, day, calendar, ArithmeticOverflow::Reject)\\n    }\\n}\\n```\\n\\nThese three constructors, `new_with_overflow`, `try_new`, and `new`, are\\nfairly flexible and provide full coverage of the Temporal specification.\\n\\nFor instance, take the below snippet:\\n\\n```js\\nconst plainDate = new Temporal.PlainDate(2025, 6, 9);\\n```\\n\\nThis code can easily be translated to Rust as:\\n\\n```rust\\nuse temporal_rs::PlainDate;\\nlet plain_date = PlainDate::try_new(2025, 6, 9, Calendar::default())?;\\n```\\n\\nFurthermore, we actually learn some interesting things about the\\nJavaScript API from looking at the `temporal_rs` API:\\n\\n1. The `Temporal.PlainDate` constructor can throw.\\n2. When the calendar is omitted, the default calendar is used (this will\\n   default to the `iso8601` calendar)\\n\\nOf course, if you somewhat prefer the brevity of the JavaScript API and\\ndon\'t want to list the default `Calendar`, `temporal_rs` provides the\\nadditional constructors `new_iso` and `try_new_iso`.\\n\\n```rust\\nuse temporal_rs::PlainDate;\\nlet plain_date = PlainDate::try_new_iso(2025, 6, 9)?;\\n```\\n\\nInterestingly enough, the `_iso` constructors are mostly expressing a\\npart of the JavaScript API, just in native Rust. This is because in\\nJavaScript the `_iso` constructors are assumed to exist due to resolving\\nan `undefined` calendar to the default ISO calendar.\\n\\n## Let\'s discuss `Now`\\n\\n> Colonel Sandurz: Now. You\'re looking at now, sir. Everything that\\n> happens now, is happening now.<br></br> Dark Helmet: What happened to\\n> then?<br></br> Colonel Sandurz: We passed then.<br></br> Dark Helmet:\\n> When?<br></br> Colonel Sandurz: Just now. We\'re at now now.<br></br>\\n> Dark Helmet: Go back to then.<br></br> Colonel Sandurz: When?<br></br>\\n> Dark Helmet: Now.<br></br> Colonel Sandurz: Now?<br></br> Dark Helmet:\\n> Now.<br></br> Colonel Sandurz: I can\'t.<br></br> Dark Helmet:\\n> Why?<br></br> Colonel Sandurz: We missed it.<br></br> Dark Helmet:\\n> When?<br></br> Colonel Sandurz: Just now.<br></br> Dark Helmet: When\\n> will then be now?<br></br> -- <cite>Spaceballs, 1987</cite>\\n\\n`Temporal.Now` is an incredibly strange type, yet nevertheless\\nimportant. It is the object from which the current instant can be\\nmeasured and mapped into any of the Temporal components.\\n\\nIn JavaScript, this type has no [`[[Construct]]`][construct-link] or\\n[`[[Call]]`][call-link] internal method, which is a fancy way to say\\nthat Now has no constructor and cannot be called directly.\\n\\nInstead, `Now` is used primarily as a namespace for its methods.\\n\\nAnd this was reflected in early adaptions of `Now`, which looked more or\\nless like the below:\\n\\n```rust\\nstruct Now;\\n\\nimpl Now {\\n    pub fn instant() -> Instant;\\n\\n    pub fn zoned_date_time_iso() -> ZonedDateTime;\\n}\\n```\\n\\nInterestingly enough, the above implementation is incorrect, or at the\\nvery least not ideal.\\n\\nHidden in the specification steps for `Now` are some very tricky steps\\ninvoking the abstract operations: `SystemTimeZoneIdentifier` and\\n`SystemUtcEpochNanoseconds`. That\'s great, let\'s just use the usual\\nsuspects `SystemTime` and `iana-time-zone`, merge it, and call it a day\\non the implementation, right?\\n\\nExcept the core purpose of `temporal_rs` is that it can be used in any\\nengine implementation, and accessing a system clock and system time zone\\nis sometimes difficult for engines that support targets like embedded\\nsystems. Thus, this functionality must be delegated to the engine or\\nruntime ... somehow.\\n\\nHow did we end up implementing `Now` if we have no access to the system\\nclock or time zone? Well ... a builder pattern of course!\\n\\n```rust\\n#[derive(Default)]\\npub struct NowBuilder {\\n    clock: Option<EpochNanoseconds>,\\n    zone: Option<TimeZone>,\\n}\\n\\nimpl NowBuilder {\\n    pub fn with_system_nanoseconds(mut self, nanoseconds: EpochNanoseconds) -> Self {\\n        self.clock = Some(nanoseconds);\\n        self\\n    }\\n\\n    pub fn with_system_zone(mut self, zone: TimeZone) -> Self {\\n        self.zone = Some(zone);\\n        self\\n    }\\n\\n    pub fn build(self) -> Now {\\n        Now {\\n            clock: self.clock,\\n            zone: self.zone.unwrap_or_default(),\\n        }\\n    }\\n}\\n\\npub struct Now {\\n    clock: Option<EpochNanoseconds>,\\n    zone: TimeZone,\\n}\\n```\\n\\nOnce we\'ve constructed `Now`, then we are off to the races!\\n\\nTo show the `NowBuilder` in action, in Boa, the implementation for\\n`Temporal.Now.plainDateISO()` with the builder API is shown below:\\n\\n```rust\\nimpl Now {\\n    // The `Temporal.Now.plainDateISO` used when building `Temporal.Now`.\\n    fn plain_date_iso(_: &JsValue, args: &[JsValue], context: &mut Context) -> JsResult<JsValue> {\\n        let time_zone = args\\n            .get_or_undefined(0)\\n            .map(|v| to_temporal_timezone_identifier(v, context))\\n            .transpose()?;\\n\\n        let now = build_now(context)?;\\n\\n        let pd = now.plain_date_iso_with_provider(time_zone, context.tz_provider())?;\\n        create_temporal_date(pd, None, context).map(Into::into)\\n    }\\n}\\n\\n// A helper for building Now\\nfn build_now(context: &mut Context) -> JsResult<NowInner> {\\n    Ok(NowBuilder::default()\\n        .with_system_zone(system_time_zone()?)\\n        .with_system_nanoseconds(system_nanoseconds(context)?)\\n        .build())\\n}\\n```\\n\\nThe nice part about this approach is that it also allows a `std`\\nimplementation that can be feature gated for general users that are not\\nconcerned with `no_std`.\\n\\n```rust\\n    // Available with the `sys` feature flag\\n    use temporal_rs::Temporal;\\n    let now = Temporal::now().instant();\\n```\\n\\n## Partial API\\n\\nThere\'s an interesting method on each of the Temporal built-ins that I\'d\\nassume most people who have used Rust would be familiar with: `from`.\\nBut this isn\'t Rust\'s friendly `From` trait. No, this `from` is a\\nbehemoth method that takes a `JsValue` and automagically gives you back\\nthe built-in that you\'d like or throws. That\'s right! Give it a string,\\ngive it a property bag, give it an instance of another Temporal\\nbuilt-in; `from` will figure it out for you!\\n\\nSimple, right?\\n\\nFolks, we\'re pleased to announce that `temporal_rs` won\'t be supporting\\nthat! ... or at least not in that shape.\\n\\nAgain, the goal of `temporal_rs` is to implement the specification to\\nthe highest possible degree of conformance, so when we couldn\'t provide\\na direct translation of the specification\'s API, we made sure to provide\\nAPIs that (hopefully) made the glue code between engines and\\n`temporal_rs` much shorter.\\n\\nTo exemplify this, let\'s take a look at some valid uses of `from` in\\nJavaScript to construct a `PlainDate`.\\n\\n```js\\n// Create a `PlainDateTime`\\nconst pdt = new Temporal.PlainDateTime(2025, 1, 1);\\n// We can use the `PlainDateTime` (`ZonedDateTime` / `PlainDate` are also options).\\nconst pd_from_pdt = Temporal.PlainDate.from(pdt);\\n// We can use a string.\\nconst pd_from_string = Temporal.PlainDate.from(\\"2025-01-01\\");\\n// We can use a property bag.\\nconst pd_from_property_bag = Temporal.PlainDate.from({\\n  year: 2025,\\n  month: 1,\\n  day: 1,\\n});\\n```\\n\\nIf we look closely to the common usage of the method, it seems like all\\nthat needs to be implemented by `temporal_rs` is:\\n\\n- `From<PlainDateTime>`: Easy.\\n- `From<ZonedDateTime>`: Simple.\\n- `FromStr`: Tricky but can be done.\\n- `From<JsObject>`: ... ... oh. Did I mention `JsObject`, like\\n  `JsValue`, is engine defined as well?\\n\\nFortunately, this is where `temporal_rs`\'s Partial API comes in.\\n\\nIt turns out that, while property bags in JavaScript can have various\\nfields set, there is still a general shape for the fields that can be\\nprovided and validated in Temporal.\\n\\nTo support this in `temporal_rs`, a \\"partial\\" component exists for each\\nof the components that can then be provided to that component\'s\\n`from_partial` method.\\n\\nWith this, we have fully implemented support for the `from` method in\\n`temporal_rs`:\\n\\n```rust\\nuse core::str::FromStr;\\nuse temporal_rs::{PlainDate, PlainDateTime, partial::PartialDate};\\nlet pdt = PlainDateTime::try_new_iso(2025, 1, 1)?;\\n// We can use the `PlainDateTime` (`ZonedDateTime` / `PlainDate` are also options).\\nlet pd_from_pdt = PlainDate::from(pdt);\\n// We can use a `str`.\\nlet pd_from_string = PlainDate::from_str(\\"2025-01-01\\")?;\\n// We can use a `PartialDate`.\\nlet pd_from_partial = PlainDate::from_partial(\\n    PartialDate::new()\\n        .with_year(Some(2025))\\n        .with_month(Some(1))\\n        .with_day(Some(1))\\n);\\n```\\n\\n**NOTE:** there may be updates to `PartialDate` in the future (see\\n[boa-dev/temporal #349](https://github.com/boa-dev/temporal/issues/349)\\nfor more information).\\n\\n## Elephant in the room: time zones\\n\\nSo far we have not discussed time zones, and -- surprise! -- we aren\'t\\ngoing to ... yet. It\'s not because they aren\'t super cool and\\ninteresting and everyone _totally_ 100% loves them. No, time zones\\naren\'t in this post because they are still being polished and deserve an\\nentire post of their own.\\n\\nSo stay tuned for our next post on implementing Temporal! The one where\\nwe\'ll hopefully go over everyone\'s favorite subject, time zones; and\\nanswer the question that some of you may have if you happen to take a\\nglance at `temporal_rs`\'s docs or try out our `no_std` support: what in\\nthe world is a provider API?\\n\\n## Conclusion\\n\\nIn conclusion, we\'re implementing Temporal in Rust to support engine\\nimplementors as well as to have the API available in native Rust in\\ngeneral.\\n\\nIf you\'re interested in trying Temporal using Boa, you can use it in\\nBoa\'s CLI or enable it in `boa_engine` with the `experimental` flag.\\n\\nOutside of Boa\'s implementation, `temporal_rs` has implemented or\\nsupports the implementation for a large portion of the Temporal\'s API in\\nnative Rust. Furthermore, an overwhelming amount of the API can be\\nconsidered stable[^stability] and is currently available in Boa with\\nonly a few outstanding issues that may be considered breaking changes.\\n\\nIf you\'re interested in trying out `temporal_rs`, feel free to add it to\\nyour dependencies with the command:\\n\\n```bash\\ncargo add temporal_rs\\n```\\n\\nor by adding the below in the `[dependencies]` section of your\\n`Cargo.toml`:\\n\\n```toml\\ntemporal_rs = \\"0.0.9\\"\\n```\\n\\nA FFI version of temporal is also available for C and C++ via\\n[`temporal_capi`][temporal-capi].\\n\\n[^stability]: A general note on API stability\\n\\n    While the majority of the APIs discussed above are expected to be\\n    mostly stable, Temporal is still a stage 3 proposal that is not\\n    fully accepted into the ECMAScript specification. Any normative\\n    change that may be made upstream in the ECMAScript or ECMA402\\n    specification will also be reflected in `temporal_rs`.\\n\\n    There are also a few outstanding issues with changes that may be\\n    reflected in the API.\\n\\n    1.  Duration\'s inner repr and related constructors.\\n    2.  `ZonedDateTime.prototype.getTimeZoneTransition` implementation\\n    3.  TemporalError\'s inner repr\\n    4.  Partial objects may need some adjustments to handle differences\\n        between `from_partial` and `with`\\n    5.  Time zone provider\'s and the `TimeZoneProvider` trait are still\\n        largely unstable. Although, the provider APIs that use them are\\n        expected to be stable (spoilers!)\\n    6.  Era and month code are still be discussed in the\\n        intl-era-month-code proposal, so some calendars and calendar\\n        methods may have varying levels of support.\\n\\n    The above issues are considered blocking for a 0.1.0 release.\\n\\n[mdn-temporal]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal\\n[temporal-rs-repo]: https://github.com/boa-dev/temporal\\n[construct-link]: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget\\n[call-link]: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-call-thisargument-argumentslist\\n[boa-test262]: https://test262.fyi/#|boa\\n[temporal-capi]: https://crates.io/crates/temporal_capi"},{"id":"/2025/03/05/local-variables","metadata":{"permalink":"/blog/2025/03/05/local-variables","source":"@site/blog/2025-03-05-local-variables.md","title":"How ECMAScript Engines Optimize Your Variables","description":"In this post, we will dive into how ECMAScript engines store variables,","date":"2025-03-05T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"},{"inline":true,"label":"internals","permalink":"/blog/tags/internals"}],"readingTime":13.2,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post","internals"],"title":"How ECMAScript Engines Optimize Your Variables","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Implementing Temporal, the new date/time API for JavaScript (and Rust!)","permalink":"/blog/2025/06/15/temporal-impl-1"},"nextItem":{"title":"Boa release v0.20","permalink":"/blog/2024/12/05/boa-release-020"}},"content":"In this post, we will dive into how ECMAScript engines store variables,\\ngo over storage optimizations, and learn about scope analysis.\\nIf you are an ECMAScript developer, you will get some practical tips to improve the performance of your code.\\nIf you write your own ECMAScript engine or any interpreter/compiler, you might get some implementation ideas.\\n\\n<!--truncate-->\\n\\nBefore we start, let\'s get some disclaimers out of the way:\\n\\n- This post is written about optimizations in the Boa ECMAScript engine.\\n  Other engines might do things different, so take everything with a grain of salt.\\n- This post omits some implementation details to focus on the most relevant parts.\\n- This post contains data structures written in pseudo Rust\\n  that are only for visualization, so you should not need to understand Rust.\\n\\n## Scopes and Variables\\n\\nTo start us off, let\'s refresh our understanding of variables and scopes in ECMAScript.\\nVariables are identifiers in our code that we can use to store and retrieve values.\\nScopes describe the areas of code in which variables are visible.\\nYou might associate scopes with curly braces.\\n\\nLet\'s look at an example to visualize scopes:\\n\\n```js\\nconst a = 1;\\nconsole.log(a); // 1\\n\\n{\\n  // <- start of a block scope\\n  const a = 2;\\n  console.log(a); // 2\\n} // <- end of a block scope\\n```\\n\\nWe declare and initialize two variables with the identifier `a`.\\nEven though both have the same identifier, they are different variables.\\nThe variable with the value `1` is declared in the global scope.\\nThe variable with the value `2` is declared in a block scope.\\n\\nIn this example, we always find the variable that we want to access in the current scope.\\nBut what when the variable we access in not declared in the current scope?\\n\\nLet\'s modify our example to see what happens in that case:\\n\\n```js\\nconst a = 1;\\n\\n{\\n  const b = 2;\\n  console.log(a); // 1\\n  console.log(b); // 2\\n}\\n```\\n\\nIn this example, our two variables have different identifiers.\\nNotice that when we access the variable `a` from the block scope, its value is resolved as expected.\\nThis is because scopes are nested.\\nWhen we cannot find a variable in the current scope, we look for the same identifier in the outer scope.\\nIn this case, we have to look for `a` in the block scope and then in the global scope.\\n\\nLet\'s look at a more complex example:\\n\\n```js\\nconst a = 1;\\nconsole.log(a); // 1\\n\\nfunction f() {\\n  // <- start of a function scope\\n  var a = 2;\\n  console.log(a); // 2\\n\\n  {\\n    // <- start of a block scope\\n    let a = 3;\\n    console.log(a); // 3\\n  } // <- end of a block scope\\n\\n  console.log(a); // 2\\n} // <- end of a function scope\\n\\nf();\\n\\nconsole.log(a); // 1\\n```\\n\\nYou can see that variables are tied to their scopes.\\nAll three variables `a` never change their values.\\nThe variables just exist in their respective scopes, and as soon as the scope has ended, they are no longer accessible.\\nInstead, the previous outer scope returns to being the current scope and its variables are accessible.\\n\\nYou can see that in addition to blocks, functions also have scopes.\\nThere are some more details to function scopes and how `let`, `const` and `var` differ.\\nFor our proposes we will only work with `let` and `const` and skip those details for now.\\n\\n## Storing Variables\\n\\n### The Naive Approach\\n\\nWhen developing an ECMAScript engine we have to think about how we store and access scopes and variables.\\nTake a look at the requirements we have for that storage data structure:\\n\\n- A variable maps an identifier to a value.\\n- A scope can have multiple variables with unique identifiers.\\n- A scope may have an outer scope.\\n\\nThe variables in a scope fit a typical key-value store, like a hashmap.\\nThe hashmap stores our variable identifiers as keys and the variable values as corresponding values:\\n\\n```rust\\nstruct Scope {\\n    variables: HashMap<Identifier, Value>,\\n}\\n```\\n\\nThis is a nice and easy data structure for our variables.\\nAnd because most languages come with a hashmap built-in, we do not have implement much!\\n\\nLet\'s add the ability to nest our scopes.\\nSince all scopes are the same, we can just build a self-referential data structure:\\n\\n```rust\\nstruct Scope {\\n    variables: HashMap<Identifier, Value>,\\n    outer: Scope,\\n}\\n```\\n\\nThis solution works and is easy to reason about.\\nThe data structures map very well on our mental model of variables and scopes.\\nThis was the approach we used in Boa before we switched to a different implementation over two years ago (https://github.com/boa-dev/boa/pull/1829).\\n\\n### Fixed Locations\\n\\nYou may already have spotted some performance issues with this data structure.\\nConsider that accessing variables is one of the things happening all the time in most languages.\\nTherefore, the runtime performance of variable access operations should be highly optimized.\\nWith this current data structure we have to perform at least one hashmap lookup per variable access.\\nMost hashmap implementations will incur significant cost compared to accessing a fixed location in memory.\\nThis problem gets worse when the variable we want to access is not in our current scope.\\nIn the worst case, we have to traverse all the scopes until we arrived at the global scope.\\n\\nHow would you optimize this data structure for runtime performance?\\nCan you find a way to locate each variable without accessing multiple hashmaps?\\n\\nWhen we read code, we can use our mental model of variables and scopes to see how each variable is unique.\\nWe just have to apply that knowledge to our data structure.\\nIn practice, we can assign each variable two indices that make it unique and give it a defined location in memory:\\n\\n- `scope index`: The index of the scope that the variable is declared in.\\n- `variable index`: The index of the variable in its scope.\\n\\nLet\'s visualize this in an example:\\n\\n```js\\nconst a = 1; // scope index: 0; variable index: 0\\n{\\n  const b = 2; // scope index: 1; variable index: 0\\n  const c = 3; // scope index: 1; variable index: 1\\n}\\n```\\n\\nYou can see how each variable has a set of two unique indices.\\nThe scope index increases with each nested scope.\\nThe variable index increases with each variable in one specific scope.\\n\\nLet\'s explore how unique these indices have to be:\\n\\n```js\\n{\\n  const a = 1; // scope index: 1; variable index: 0\\n}\\n{\\n  const b = 2; // scope index: 1; variable index: 0\\n}\\n```\\n\\nAs you can see, both `a` and `b` have a scope index of `1` and a variable index of `0`.\\nThis works for us, because variables do not have to be unique for the whole program.\\nThey just have to be unique in their current nested tree of scopes.\\n\\nWith all of this in mind, we can build a data structure that allows us to access variables just based on these two indices.\\nIt might look something like this:\\n\\n```rust\\nstruct Scopes {\\n    scopes: Array<Scope>,\\n}\\n\\nstruct Scope {\\n    variables: Array<Value>,\\n}\\n```\\n\\nInstead of having a self-referential data structure, we now have a two-dimensional array.\\n\\nWhile this is our runtime data structure, we still have to calculate the variable indices before running the code.\\nFor that we can use our previous approach with some slight modifications.\\nInstead of storing the value of the variable, we just store its index.\\nAdditionally, we store an index in every scope to easily access our scope indices:\\n\\n```rust\\nstruct Scope {\\n    index: u32,\\n    variables: HashMap<Identifier, Variable>,\\n    outer: Scope,\\n}\\n\\nstruct Variable {\\n    index: u32,\\n}\\n```\\n\\nWhile this data structure still works based on self-referential hashmaps, we only need it before running code.\\nInstead of doing a lookup on every variable access at runtime, we just have to do it once.\\n\\n## Local Variables\\n\\nOur previous optimization changed the data structure for our variables and scopes.\\nBut we can come up with further optimizations if we look at the usage of variables in the code.\\n\\nLet\'s take a look at this example:\\n\\n```js\\nfunction addOne(a) {\\n  const one = 1;\\n  return one + a;\\n}\\naddOne(2);\\n```\\n\\nCurrently, we store `a` and `one` in our scopes and access them when performing the addition.\\nBut why do we need the special data structure for variables and scopes at all?\\nWhat if we could just store the variables directly where we need them?\\n\\nA typical ECMAScript engine uses a virtual machine (VM) to execute your code.\\nVMs use dedicated memory for values they operate on; a stack or registers.\\nFor the purpose of this post, we use registers, but the stack would work in the same way.\\nLet\'s try to use registers to store variables.\\nWhile compiling the ECMAScript code into operations for our VM, we assign each variable to a register.\\nThen we modify our variable operations to use registers instead of scopes to access variables.\\n\\nWhen we test our example from above, it works fine with these changes.\\nLet\'s write down what exactly happens:\\n\\n1. The function `addOne` is called. Registers for `a` and `one` are allocated.\\n2. The first function argument with the value `2` is written to the register for `a`.\\n3. The value `1` is written to the register for `one`.\\n4. The values from the registers `a` and `one` are read and added together.\\n\\n### Nested Functions\\n\\nWhen testing some more complex code we will quickly see that something does not work as expected.\\n\\nLet\'s look at this example:\\n\\n```js\\nfunction addOneBuilder() {\\n  const one = 1;\\n  return (a) => {\\n    return one + a;\\n  };\\n}\\nconst addOne = addOneBuilder();\\naddOne(2);\\n```\\n\\nWhile running the code, depending on the implementation, we might get a panic, a wrong result or even an unsafe memory access.\\nLet\'s try to understand what is going on here:\\n\\n1. The function `addOneBuilder` is called. A register for `one` is allocated.\\n2. The value `1` is written to the register for `one`.\\n3. The function `addOneBuilder` returns the arrow function bound to `addOne`.\\n4. The function `addOne` is called. A register for `a` is allocated.\\n5. The first function argument with the value `2` is written to the register for `a`.\\n6. The VM tries to access the register for `one`. This is the point where our things go wrong.\\n\\nRegisters in a VM are local to a specific function.\\nIn our example this means that the variable `one` can only be accessed successfully in the function `addOneBuilder`.\\nAs soon as we try to access it from `addOne`, the register we assigned during compilation does not hold the correct value anymore.\\nThis is why this optimization can be referred to as `local variables` or `function local variables`.\\n\\nWe now know that variables that are used in nested functions cannot be used as local variables.\\nBut this should not stop us from using the optimization.\\nWe just have to find all the variables that cannot be optimized.\\nThen we can use our existing scopes to store those, while optimizing all the other ones.\\n\\n## Scope Analysis\\n\\n### Finding Variables accessed by other Functions\\n\\nTo determine which variables can be stored in registers, we analyze them prior to code execution.\\nWe can reuse our previously established scope structure based on hashmaps.\\nIt just needs some additional information to make our analysis work.\\nEach scope needs to be flagged to indicate if it is a function scope.\\nThis is important, because we have to track if a variable is ever accessed from a nested function.\\nAdditionally, each variable needs a flag to indicate if it can be a local variable.\\n\\nOur adjusted scope structure looks like this:\\n\\n```rust\\nstruct Scope {\\n    index: u32,\\n    function: bool, // <- This field is new\\n    variables: HashMap<Identifier, Variable>,\\n    outer: Scope,\\n}\\n\\nstruct Variable {\\n    index: u32,\\n    local: bool, // <- This field is new\\n}\\n```\\n\\nWe set the `function` flag on each scope when it is created.\\nThe `local` flag on the variables is `true` by default.\\nAfter creating all the scopes and filling them with their variables, we traverse the ECMAScript code.\\nEvery time we find a variable access, we check which variable in which scope is being accessed.\\nIf a variable is not in the current scope, we go to the `outer` scope.\\nIf any of the scopes we see until we find the variable is a function scope, we set the `local` flag to `false`.\\n\\nLet\'s visualize the scope analysis by writing out the scopes for this example:\\n\\n```js\\nfunction addOneBuilder() {\\n  const one = 1;\\n  return (a) => {\\n    return one + a;\\n  };\\n}\\n```\\n\\nThese are our scopes before the scope analysis.\\nNotice that we start from the scope of the arrow function, since we work our way out from the most nested scope:\\n\\n```rust\\nScope {\\n    function: true\\n    variables: [\\n        \\"a\\": {\\n            index: 0,\\n            local: true,\\n        }\\n    ]\\n    outer: Scope {\\n        function: true\\n        variables: [\\n            \\"one\\": {\\n                index: 0,\\n                local: true,\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nNow we apply our scope analysis.\\nDuring the access to variable `one` in the arrow function, we pass the function scope of the arrow function.\\nThis indicates that this variable cannot be local:\\n\\n```rust\\nScope {\\n    function: true\\n    variables: [\\n        \\"a\\": {\\n            index: 0,\\n            local: true, // <- Still `true`\\n        }\\n    ]\\n    outer: Scope {\\n        function: true\\n        variables: [\\n            \\"one\\": {\\n                index: 0,\\n                local: false, // <- Set to `false`\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nAfter the scope analysis is finished, we compile our code for the VM.\\nWhen we encounter a variable that can be local, we assign it a register.\\nWhen we encounter a variable that cannot be local, we use the old VM operations for our scopes storage.\\n\\n### Other Exceptions\\n\\nThere are some more situations that prevent us from using local variables.\\nWe have to account for every case where a variable might be accessed from outside its function.\\nWithout going into detail on each of these cases, we can find all of them via scope analysis.\\n\\nHere is a quick overview:\\n\\n- Non `strict` functions create a mapped `arguments` object.\\n  The mapped `arguments` object can be used to read and write function arguments without using their identifiers.\\n  The reads and writes are kept in sync with the values of the argument variables.\\n  This means that we cannot determine if the argument variables are accessed from outside the function.\\n\\n  An example of such a situation would be this code:\\n\\n  ```js\\n  function f(a) {\\n    console.log(a); // initial\\n    (() => {\\n      arguments[0] = \\"modified\\";\\n    })();\\n    console.log(a); // modified\\n  }\\n  f(\\"initial\\");\\n  ```\\n\\n  The solution here is to mark every argument variable that might be accessed through a mapped `arguments` object as non-local.\\n\\n- Direct calls to `eval` allow potential variable access.\\n  Direct calls to `eval` have access to the current variables.\\n  Since any code could be executed in `eval` we cannot do proper scope analysis on any variables in such cases.\\n\\n  An example of direct `eval` usage would be this:\\n\\n  ```js\\n  function f() {\\n    const a = 1;\\n    eval(\\"function nested() {console.log(a)}; nested();\\");\\n  }\\n  f();\\n  ```\\n\\n  Our solution is this case is to mark every variable in the scopes where the direct `eval` call is as non-local.\\n\\n- Usage of the `with` statement.\\n  Variable identifiers inside a `with` statement are not static.\\n  A variable identifier could be the access to a variable, but it also could be the access to an object property.\\n\\n  See this example:\\n\\n  ```js\\n  function f() {\\n    const a1 = 1;\\n    for (let i = 0; i < 2; i++) {\\n      with ({ [`a${i}`]: 2 }) {\\n        console.log(a1);\\n      }\\n    }\\n  }\\n  f();\\n  ```\\n\\n  In the first loop execution `a1` is the variable.\\n  In the second loop execution `a1` is the object property.\\n  As a result of this behavior, every variable accessed inside a `with` statement cannot be local.\\n\\n## Conclusion\\n\\nAfter implementing local variables in Boa, we saw significant performance improvements in our benchmarks.\\nOur overall benchmark scope improved by more than 25%.\\nIn one specific benchmark the scope increased by over 70%.\\nNotice that Boa is not the most performant engine yet.\\nThere are probably other optimizations relating to variable storage that we have not implemented yet.\\n\\nHopefully, you might have already picked up some practical tips to potentially improve to performance of your ECMAScript code.\\nHere are our observations that might help performance:\\n\\n- Avoid accessing variables across functions.\\n  This might just help the ECMAScript engine to optimize your code better.\\n- Always use `strict` mode.\\n- [Never use direct `eval`!](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_direct_eval!)\\n- Never use the `with` statement."},{"id":"/2024/12/05/boa-release-020","metadata":{"permalink":"/blog/2024/12/05/boa-release-020","source":"@site/blog/2024-12-05-boa-release-020/index.mdx","title":"Boa release v0.20","description":"Boa release v0.20","date":"2024-12-05T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":9.61,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.20","description":"Boa release v0.20","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"How ECMAScript Engines Optimize Your Variables","permalink":"/blog/2025/03/05/local-variables"},"nextItem":{"title":"Boa release v0.19","permalink":"/blog/2024/07/09/boa-release-19"}},"content":"## Summary\\n\\nBoa v0.20 is now available! After 5 months of development we are very happy to present you the latest\\nrelease of the Boa JavaScript engine. Boa makes it easy to embed a JS engine in your projects, and\\nyou can even use it from WebAssembly. See the [about](/about) page for more info.\\n\\nIn this release, our conformance has grown from 87.3% to 89.92% in the official ECMAScript Test Suite\\n(Test262). This small jump is expected as we\'re shifting most of our focus to performance as the majority of the engine is now conformant. We will continue to implement more of the specification as we go along but we expect these changes to be much smaller than we\'ve been used to.\\n\\nYou can check the full list of changes [here][changelog], and the full information on conformance\\n[here][conformance].\\n\\n<!--truncate-->\\n\\n## Feature Highlights\\n\\n### Temporal\\n\\nBoa is continuing to progress on [Temporal](https://github.com/tc39/proposal-temporal). The Temporal API is a new\\nset of built-in objects and functions that is designed to be a more modern replacement for the `Date`\\nobject, providing a more feature-rich and flexible API for working with dates and times.\\n\\nIt is currently a [stage 3 proposal](https://tc39.es/proposal-temporal/docs/) and we are working\\nalongside the TC39 champions to put together a solid Rust implementation. Since Temporal is such an\\nextensive specification, we have done most of the work outside of Boa so that it can be used in other\\nprojects. This work can be found in the [temporal_rs](https://github.com/boa-dev/temporal/) repository.\\n\\nWe hope to release a full blog post on Temporal in the future, but for now you can see the previous release notes for some examples on how to use it.\\nYou can also look at the [Temporal Cook Book](https://tc39.es/proposal-temporal/docs/cookbook.html) for some examples too!\\n\\nIf you\'re interested in learning more or want to contribute to the native Rust implementation of\\nTemporal, feel free to check out `temporal_rs`\'s [issues](https://github.com/boa-dev/temporal/issues)!\\n\\nBoa\'s conformance on the Temporal test suite has grown from 24.61% to 40.67% in this release.\\n\\n### Nightlies\\n\\nBoa now supports nightly releases, this was originally created to aid with the testing of conformance for test262.fyi. This is a great way to see the latest changes and help offer feedback on new features or just to see the latest changes in the engine. You can find the nightly releases [here](https://github.com/boa-dev/boa/releases/tag/nightly)\\n\\n### Atomics.pause\\n\\nBoa has added support for the [stage 3 proposal `Atomics.pause`](https://github.com/tc39/proposal-atomics-microwait). This function is used to pause the execution of a thread for a specified amount of time. This function is useful for implementing spinlocks and other synchronization primitives in JavaScript.\\n\\n### Getters and Setters in the js_class! macro\\n\\nYou can now add getters and setters to the `js_class!` macro. This allows you to define getters and setters on your JavaScript classes in Rust. This is a feature that has been requested by many users of Boa, and thanks to @hansl we now have it!\\n\\n```rust\\n#[derive(Clone, Default, Trace, Finalize, JsData)]\\npub struct Game {\\n    score: u32,\\n}\\n\\njs_class! {\\n    class Game {\\n        property score {\\n            get(this: JsClass<Game>) -> u32 {\\n                this.borrow().score\\n            }\\n\\n            set(this: JsClass<Game>, new_value: u32) {\\n                this.borrow_mut().score = new_value;\\n            }\\n        }\\n\\n        constructor() {\\n            Ok(Game::default())\\n        }\\n    }\\n}\\n```\\n\\n### Implement your own native Errors\\n\\nEmbedders can now create native errors in Rust and pass them into the JavaScript environment.\\nThe below example creates a new `JsError` from a Rust standard error [`err`](https://doc.rust-lang.org/std/error/trait.Error.html). This will create a new `JsNativeError` with the message of the standard error.\\n\\n```rust\\nuse boa_engine::JsError;\\n\\nlet error = std::io::Error::new(std::io::ErrorKind::Other, \\"oh no!\\");\\nlet js_error: JsError = JsError::from_rust(error);\\n\\nassert_eq!(js_error.as_native().unwrap().message(), \\"oh no!\\");\\nassert!(js_error.as_native().unwrap().cause().is_none());\\n```\\n\\n## Boa Runtime\\n\\nBoaâs boa_runtime crate contains an example runtime and basic runtime features and functionality for the boa_engine crate for runtime implementors.\\nShout out to [@hansl](https://github.com/hansl) for their work on the additional features of the Boa runtime crate.\\n\\n### Additional APIs\\n\\nAdditional APIs added the the Runtime crate include:\\n\\n- [`TextDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder)\\n- [`TextEncoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder)\\n- [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL)\\n- [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).\\n\\n### Console Improvements\\n\\nThere is also [context added](https://github.com/boa-dev/boa/pull/4005) to the console\'s `Logger` trait. This change modifiers the `Logger` trait to accept `ConsoleState` and `Context` paramters. This allows the `Logger` to be aware of the context in which it is being called, and to log messages accordingly. This is useful for debugging and logging in Boa.\\n\\nSee [here](https://docs.rs/boa_runtime/latest/boa_runtime/index.html) for more information on Boa runtime.\\n\\n## Performance\\n\\n### Escape Analysis and local variables\\n\\nThanks to @raskad who has been [working on improving scope analysis](https://github.com/boa-dev/boa/pull/3988) in the engine\'s AST. There has been so much improvement we plan to release a blog post shortly after detailing the changes and how they have improved the engine\'s performance.\\n\\nMost of the changes in the AST are the addition of [Scopes](https://github.com/boa-dev/boa/blob/1c4f455554b4140910241e86f90474ae3ff9f095/core/ast/src/scope.rs#L19-L25) to relevant AST nodes like [functions](https://github.com/boa-dev/boa/blob/main/core/ast/src/function/arrow_function.rs#L33) or [blocks](https://github.com/boa-dev/boa/blob/1c4f455554b4140910241e86f90474ae3ff9f095/core/ast/src/statement/block.rs#L47-L53).\\nScopes contain bindings, that we previously created during bytecode compilation.\\nNow they are added to the AST after parsing.\\n\\nThe scope analyzer contains new visitor code that creates bindings and looks for bindings that escape their function scope. This allows us to only visit the scope environment for variables that are used outside of their scope, whilst keeping local variables on the stack. This is a big performance improvement as we no longer need to visit the entire scope environment for every variable in the function.\\n\\nimport ThemedImage from \\"@theme/ThemedImage\\";\\nimport perf_changes_light from \\"./img/perf-changes-light.png\\";\\nimport perf_changes_dark from \\"./img/perf-changes-dark.png\\";\\n\\n<ThemedImage\\n  alt=\\"Performance changes in the benchmarks\\"\\n  sources={{\\n    light: perf_changes_light,\\n    dark: perf_changes_dark,\\n  }}\\n/>\\n\\n<center>_V8 Benchmark overall score, higher is better..._</center>\\n\\n### Error optimizations\\n\\nThanks to the work from [@CrazyboyQCD](https://github.com/CrazyboyQCD) we have improved performance on the Error messages and native errors. Error messages now use Rust\'s [Cow](https://doc.rust-lang.org/std/borrow/enum.Cow.html) type to avoid unnecessary allocations. `JSNativeError` constructors are also now marked as `const` which means much fewer instructions generated when creating a new error. See the [PR](https://github.com/boa-dev/boa/pull/4020) plus the changes in godbolt [here](https://godbolt.org/z/YEq4hW49n).\\n\\n### String optimizations\\n\\nOur string representation was refactored by [@CrazyboyQCD](https://github.com/CrazyboyQCD).\\nThanks to the changes, string literals can now be created without heap allocations.\\nBuilding on these changes, [@CrazyboyQCD](https://github.com/CrazyboyQCD) also adjusted all places in our crates where this new capability could be applied.\\n\\nYou can find the details in the relevant PRs [3935](https://github.com/boa-dev/boa/pull/3935) and [4030](https://github.com/boa-dev/boa/pull/4030).\\n\\n### Lazy loading of ICU data\\n\\nBoa now lazily loads [ICU](https://icu.unicode.org/design/cldr-support) data on demand instead of during startup, this is a big performance improvement as we no longer need to load all the ICU data which can be quite large. This code change includes the addition of a [`LazyBufferProvider`](https://github.com/boa-dev/boa/blob/1c4f455554b4140910241e86f90474ae3ff9f095/core/icu_provider/src/lib.rs#L32-L40) which lazily deserializes the ICU data when first called upon.\\n\\nOn top of this we have also broken up the ICU data into smaller chunks called postcards (datetime, plurals, segmenters, decimals), this means we can load only the data we need when we need it.\\n\\nYou can see more details on the changes in the [PR](https://github.com/boa-dev/boa/pull/3948).\\n\\n## New Contributors\\n\\nThank you to the new contributors to Boa for this release, you can find their contributions below:\\n\\n- [@magic-akari](https://github.com/@magic-akari) made their first contribution in https://github.com/boa-dev/boa/pull/3916\\n- [@shurizzle](https://github.com/@shurizzle) made their first contribution in https://github.com/boa-dev/boa/pull/3976\\n- [@it-a-me](https://github.com/@it-a-me) made their first contribution in https://github.com/boa-dev/boa/pull/4007\\n- [@Nikita-str](https://github.com/@Nikita-str) made their first contribution in https://github.com/boa-dev/boa/pull/4010\\n- [@4yman-0](https://github.com/@4yman-0) made their first contribution in https://github.com/boa-dev/boa/pull/4046/\\n\\n## Looking Forward\\n\\n### Register VM\\n\\nNow that we [have register](https://github.com/boa-dev/boa/pull/3942) allocation merged @HalidOdat has been working on migrating from a Stack VM to a Register VM, the register VM should mean less accesses to the heap as we utilize register allocation more. Secondly, by resembling the lower level architecture (in terms of low-level operations), we can compile down to efficient machine languauge easier in future when looking into JIT compilation.\\n\\n### Lazy Built-ins\\n\\nAll builtins are eagerly initialized when the engine starts up, this is not ideal as it can slow down the startup time of the engine. We are looking to change this so that builtins are lazily initialized when they are first accessed. This should improve the startup time of the engine and reduce the memory footprint. You can follow the progress of this work [here](https://github.com/boa-dev/boa/pull/3973)\\n\\n## How can you support Boa?\\n\\nBoa is an independent JavaScript engine implementing the ECMAScript specification, and we rely on the\\nsupport of the community to keep it going. If you want to support us, you can do so by donating to\\nour [open collective]. Proceeeds here go towards this very website, the domain name, and remunerating\\nmembers of the team who have worked on the features released.\\n\\nIf financial contribution is not your strength, you can contribute by asking to be assigned to one of\\nour [open issues], and asking for mentoring if you don\'t know your way around the engine. Our\\n[contribution guide] should help you here. If you are more used to working with JavaScript or frontend\\nweb development, we also welcome help to improve our web presence, either in [our website], or in our\\n[testing representation] page or benchmarks page. You can also contribute to our Criterion benchmark\\ncomparison GitHub [action].\\n\\nWe are also looking to improve the documentation of the engine, both for developers of the engine\\nitself and for users of the engine. Feel free to contact us in [Matrix].\\n\\n[open collective]: https://opencollective.com/boa\\n[open issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+no%3Aassignee\\n[contribution guide]: https://github.com/boa-dev/boa/blob/main/CONTRIBUTING.md\\n[our website]: https://github.com/boa-dev/boa-dev.github.io\\n[testing representation]: https://github.com/boa-dev/boa/issues/820\\n[action]: https://github.com/boa-dev/criterion-compare-action\\n[Matrix]: https://matrix.to/#/#boa:matrix.org\\n\\n## Thank You\\n\\nOnce again, big thanks to [all the contributors][contributors] of this release!!\\n\\n[contributors]: https://github.com/boa-dev/boa/graphs/contributors?from=2024-03-05&to=2024-07-11&type=c\\n[changelog]: https://github.com/boa-dev/boa/blob/v0.19/CHANGELOG.md\\n[conformance]: https://boajs.dev/boa/test262/\\n[feed]: https://boajs.dev/blog/rss.xml\\n[collective]: https://opencollective.com/boa\\n[easy_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3AE-Easy\\n[first_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22"},{"id":"/2024/07/09/boa-release-19","metadata":{"permalink":"/blog/2024/07/09/boa-release-19","source":"@site/blog/2024-07-09-boa-release-19.md","title":"Boa release v0.19","description":"More progress on Temporal, new benchmarks, migration to Matrix, and more...","date":"2024-07-09T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":10.06,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.19","description":"More progress on Temporal, new benchmarks, migration to Matrix, and more...","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.20","permalink":"/blog/2024/12/05/boa-release-020"},"nextItem":{"title":"Boa release v0.18","permalink":"/blog/2024/03/07/boa-release-18"}},"content":"## Summary\\n\\nBoa v0.19 is now available! After 4 months of development we are very happy to present you the latest\\nrelease of the Boa JavaScript engine. Boa makes it easy to embed a JS engine in your projects, and\\nyou can even use it from WebAssembly. See the [about](/about) page for more info.\\n\\nIn this release, our conformance has grown from 85.03% to 87.3% in the official ECMAScript Test Suite\\n(Test262). Interestingly, this was partly because around 2000 tests\\nwere [removed from test262](https://github.com/tc39/test262/commit/ea2268aa4382013f5533b91f9ef50366ad065a86)\\nas part of the [removal of custom calendars and timezones](https://github.com/tc39/proposal-temporal/issues/2826).\\nOverall, Boa\'s conformance in real terms has improved by ~6%.\\n\\nYou can check the full list of changes [here][changelog], and the full information on conformance\\n[here][conformance].\\n\\n<!--truncate-->\\n\\n## Highlights\\n\\n### Temporal\\n\\nBoa is continuing to progress on [Temporal](https://github.com/tc39/proposal-temporal). The Temporal API is a new\\nset of built-in objects and functions that is designed to be a more modern replacement for the `Date`\\nobject, providing a more feature-rich and flexible API for working with dates and times.\\n\\nIt is currently a [stage 3 proposal](https://tc39.es/proposal-temporal/docs/) and we are working\\nalongside the TC39 champions to put together a solid Rust implementation. Since Temporal is such an\\nextensive specification, we have done most of the work outside of Boa so that it can be used in other\\nprojects. This work can be found in the [temporal_rs](https://github.com/boa-dev/temporal/) repository.\\n\\nWe hope to release a full blog post on Temporal in the future, but for now you can see the previous release notes for some examples on how to use it.\\nYou can also look at the [Temporal Cook Book](https://tc39.es/proposal-temporal/docs/cookbook.html) for some examples too!\\n\\nIf you\'re interested in learning more or want to contribute to the native Rust implementation of\\nTemporal, feel free to check out `temporal_rs`\'s [issues](https://github.com/boa-dev/temporal/issues)!\\n\\nBoa\'s conformance on the Temporal test suite has grown from 19.35% to 24.61% in this release.\\n\\n### New Benchmark Suite, Faster CI and reduced repo size\\n\\nBoa has had an overhaul of its older criterion benchmark suite to a new [end to end benchmark suite](https://boajs.dev/benchmarks).\\nWe had finally outgrown the old benchmark suite and needed a new one that could handle the new features and improvements we were making to the engine.\\nThe former benchmark suite has been there almost since the beginning, and was created as a way to keep an eye on certain functions and routines within Boa itself. Although useful, it\\nwasn\'t comparable to other engines due to being so specific on how Boa works.\\n\\nThe new suite is taken from [V8\'s old benchmark suite](https://github.com/mozilla/arewefastyet/tree/master/benchmarks/v8-v7) which, despite being deprecated, is still for comparative performance.\\nOver time we will eventually need to work with other engines to have a more advanced benchmarking suite which can take into account modern JavaScript, but for now this is a good start.\\n\\nThis change also offered a nice side effect of not having benchmark or test262 data in the main repository anymore. Last time we released we had [reports](https://www.reddit.com/r/rust/comments/1b91ora/comment/ktue8rf/) of the repository being too large, so we\'ve taken steps to reduce the size of the repository by moving this data to a separate repository and building a nightly version for reporting. Not only this makes it easier for anyone cloning Boa today but pushes to `main` are now much faster due to us not having to run test262 or Benchmarks each time.\\n\\n### Migration to Matrix\\n\\nThe Boa team will be migrating to Matrix from our Discord servers over the course of this year. This means we will hang out in the [`#boa:matrix.org`](https://matrix.to/#/#boa:matrix.org) room and will be available for questions and discussions there. We will also be using Matrix for other break-out rooms on future development in areas such as [Performance](https://matrix.to/#/!odQJQiuPFJtUBzgoXY:matrix.org?via=matrix.org&via=mozilla.org), [Intl](https://matrix.to/#/!rsWLMsIzfquQAbDoak:matrix.org?via=matrix.org) and [Temporal](https://matrix.to/#/!DeQjFAUjAPAffIsCgq:matrix.org?via=matrix.org&via=mozilla.org&via=igalia.com). We will be keeping the Discord server open for a while to allow people to migrate over, but we will eventually close it down sometime in 2025.\\n\\nBoa has long been a user of Discord, pretty much since the beginning of the project, but as the project has grown and matured, we have chosen to move more in line to other communities who use Matrix for communication, such as TC39 who work on ECMAScript standard. With Boa\'s increased conformance and ability to work closer with the standard committee when implementing Temporal and other new specifications meant that a migration to Matrix was the most natural choice to ease communication with the broader JavaScript implementer communities.\\n\\n### Optimizations\\n\\n#### Release binary stripping\\n\\nBoa\'s binaries are on the larger side by default due to including ICU data. We may eventually move to a system where this needs to be fed from the host. However, until then there are other tricks we can employ to bring down our size, one of those is binary stripping. We can remove debug information from the release binary to reduce the size.\\n\\n| crate      | v0.18 | v0.19 |\\n| ---------- | ----- | ----- |\\n| boa        | 26MB  | 25MB  |\\n| boa_tester | 27MB  | 25MB  |\\n\\n#### Dense array storage variants for i32 and f64\\n\\nThis release adds [dense array storage](https://github.com/boa-dev/boa/pull/3760) variants for `i32` and `f64` types. This allows us to store arrays of these types more efficiently, and also allows us to optimize certain operations on these arrays.\\n\\nIf you want to inspect the storage type of an array in Boa you can use the `$boa.object.indexedStorageType()` APi. Here are [some examples](https://github.com/boa-dev/boa/blob/d3e539593fe206f18d44f20498cb54be15477a58/docs/boa_object.md#function-boaobjectindexedstoragetypeobject):\\n\\n```js\\nlet a = [1, 2];\\n\\n$boa.object.indexedStorageType(a); // \'DenseI32\'\\n\\na.push(0xdeadbeef);\\n$boa.object.indexedStorageType(a); // \'DenseI32\'\\n\\na.push(0.5);\\n$boa.object.indexedStorageType(a); // \'DenseF64\'\\n\\na.push(\\"Hello\\");\\n$boa.object.indexedStorageType(a); // \'DenseElement\'\\n\\na[100] = 100; // Make a hole\\n$boa.object.indexedStorageType(a); // \'SparseElement\'\\n```\\n\\nMuch of this work is possible thanks to our implementation of [Object Shapes](https://github.com/boa-dev/boa/blob/main/docs/shapes.md)\\n\\n## New Contributors\\n\\nThank you to the new contributors to Boa for this release, you can find their contributions below:\\n\\n- [@robot-head](https://github.com/robot-head) made their first contribution in https://github.com/boa-dev/boa/pull/3730\\n- [@hansl](https://github.com/hansl) made their first contribution in https://github.com/boa-dev/boa/pull/3755\\n- [@NickTomlin](https://github.com/NickTomlin) made their first contribution in https://github.com/boa-dev/boa/pull/3793\\n- [@linusg](https://github.com/linusg) made their first contribution in https://github.com/boa-dev/boa/pull/3800\\n- [@getong](https://github.com/getong) made their first contribution in https://github.com/boa-dev/boa/pull/3836\\n- [@leoflalv](https://github.com/leoflalv) made their first contribution in https://github.com/boa-dev/boa/pull/3867\\n- [@CrazyboyQCD](https://github.com/CrazyboyQCD) made their first contribution in https://github.com/boa-dev/boa/pull/3898\\n\\n## Looking Forward\\n\\n### API ergonomics\\n\\nBefore finishing this blog post, we wanted to give a special shoutout to [@hansl](https://github.com/hansl), one of our new\\ncontributors for this release! He\'s been working on improving the ergonomics around exposing\\nRust functions and types as ECMAScript functions and classes with a lot of nice API enhancements.\\nSome notable PRs are:\\n\\n- [Add a boa_interop crate](https://github.com/boa-dev/boa/pull/3772)\\n- [Add a new type Convert\\\\<\\\\> to convert values](https://github.com/boa-dev/boa/pull/3786)\\n- [Add a ContextData struct to inject host defined types from the context](https://github.com/boa-dev/boa/pull/3802)\\n- [Add a js_class to implement the Class trait without boilerplate](https://github.com/boa-dev/boa/pull/3872)\\n\\nUnfortunately, the aforementioned `boa_interop` crate was not published for this version, and that\'s\\nbecause we would like to polish it first and integrate it within the other crates of the project.\\nHowever, we can give you a sneak peek of what some of the new APIs will allow you to do. Hopefully\\nthis will make you look forward for v0.20!\\n\\n```rust\\nuse boa_interop::{js_class, Ignore, JsClass};\\n\\n#[derive(Clone, Trace, Finalize, JsData)]\\npub enum Animal {\\n    Cat,\\n    Dog,\\n    Other,\\n}\\n\\njs_class! {\\n    // Implements the [`Class`] trait for the `Animal` enum.\\n    class Animal {\\n        // This sets a field on the JavaScript object. The arguments to\\n        // `init` are the arguments passed to the constructor.\\n        public age(_name: Ignore, age: i32) -> i32 {\\n            age\\n        }\\n        // This is called when a new instance of the class is created in\\n        // JavaScript, e.g. `new Animal(\\"cat\\")`.\\n        constructor(name: String) {\\n            match name.as_str() {\\n                \\"cat\\" => Ok(Animal::Cat),\\n                \\"dog\\" => Ok(Animal::Dog),\\n                _ => Ok(Animal::Other),\\n            }\\n        }\\n        // Declare a function on the class itself.\\n        fn speak(this: JsClass<Animal>) -> JsString {\\n            match *this.borrow() {\\n                Animal::Cat => js_string!(\\"meow\\"),\\n                Animal::Dog => js_string!(\\"woof\\"),\\n                Animal::Other => js_string!(r\\"Â¯\\\\_(ã)_/Â¯\\"),\\n            }\\n        }\\n    }\\n}\\n```\\n\\n### Performance\\n\\nNow that our conformance is farily high (87.3% in Test262), we will be focusing on improving the performance of the engine. This will involve re-writing the Garbage Collector from the one we have now which was a fork of [rust-gc](https://github.com/Manishearth/rust-gc) and modified heavily, to something which will work better for the engine and allow us to have paritioning, snapshots and other features which are not possible with the current GC. If this interests you, you can join the effort in our Matrix GC chat (see [Migration To Matrix](#migration-to-matrix) above).\\n\\nBoa will also be working on [migrating](https://github.com/boa-dev/boa/pull/3798) from a stack VM to a register-based VM. This will allow us to optimize the engine further and make it more competitive with other engines. We will also be working on improving the performance of the engine in general, and we will be looking at ways to make the engine faster and more efficient.\\n\\n### v1.0\\n\\nWe hope that the changes mentioned above will bring us closer to a v1.0 release. We are still some way off, but we are making progress and we are confident that we will be able to release a v1.0 version of Boa in the future.\\n\\n## How can you support Boa?\\n\\nBoa is an independent JavaScript engine implementing the ECMAScript specification, and we rely on the\\nsupport of the community to keep it going. If you want to support us, you can do so by donating to\\nour [open collective]. Proceeeds here go towards this very website, the domain name, and remunerating\\nmembers of the team who have worked on the features released.\\n\\nIf financial contribution is not your strength, you can contribute by asking to be assigned to one of\\nour [open issues], and asking for mentoring if you don\'t know your way around the engine. Our\\n[contribution guide] should help you here. If you are more used to working with JavaScript or frontend\\nweb development, we also welcome help to improve our web presence, either in [our website], or in our\\n[testing representation] page or benchmarks page. You can also contribute to our Criterion benchmark\\ncomparison GitHub [action].\\n\\nWe are also looking to improve the documentation of the engine, both for developers of the engine\\nitself and for users of the engine. Feel free to contact us in [Matrix].\\n\\n[open collective]: https://opencollective.com/boa\\n[open issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+no%3Aassignee\\n[contribution guide]: https://github.com/boa-dev/boa/blob/main/CONTRIBUTING.md\\n[our website]: https://github.com/boa-dev/boa-dev.github.io\\n[testing representation]: https://github.com/boa-dev/boa/issues/820\\n[action]: https://github.com/boa-dev/criterion-compare-action\\n[Matrix]: https://matrix.to/#/#boa:matrix.org\\n\\n## Thank You\\n\\nOnce again, big thanks to [all the contributors][contributors] of this release!!\\n\\n[contributors]: https://github.com/boa-dev/boa/graphs/contributors?from=2024-03-05&to=2024-07-11&type=c\\n[changelog]: https://github.com/boa-dev/boa/blob/v0.19/CHANGELOG.md\\n[conformance]: https://boajs.dev/boa/test262/\\n[feed]: https://boajs.dev/blog/rss.xml\\n[collective]: https://opencollective.com/boa\\n[easy_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3AE-Easy\\n[first_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22"},{"id":"/2024/03/07/boa-release-18","metadata":{"permalink":"/blog/2024/03/07/boa-release-18","source":"@site/blog/2024-03-07-boa-release-18.md","title":"Boa release v0.18","description":"Summary","date":"2024-03-07T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":20.34,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.18","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.19","permalink":"/blog/2024/07/09/boa-release-19"},"nextItem":{"title":"Boa release v0.17","permalink":"/blog/2023/07/08/boa-release-17"}},"content":"## Summary\\n\\nBoa v0.18 is now available! After 7 months of development we are very happy to present you the latest\\nrelease of the Boa JavaScript engine. Boa makes it easy to embed a JS engine in your projects, and\\nyou can even use it from WebAssembly. See the [about](/about) page for more info.\\n\\nIn this release, our conformance has grown from 79.36% to 85.03% in the official ECMAScript Test Suite\\n(Test262). This means we now pass **3,550** more tests than in the previous version. Moreover, our\\namount of ignored tests decreased from **9,496** to **1,391** thanks to all the new builtins we have\\nimplemented for this release.\\n\\nYou can check the full list of changes [here][changelog], and the full information on conformance\\n[here][conformance].\\n\\nYou probably noticed that something seems different... This release marks a major update to the design\\nof our website, and the introduction of our new logo!\\nWe\'d like to thank [@ZackMitkin](https://github.com/ZackMitkin) for being the one that started the\\nwork on this nifty redesign, and [@kelbazz](https://github.com/kelbazz) for designing the logo.\\nWe\'re planning to add some additional pages to learn more about the APIs that Boa exposes.\\nAdditionally, expect some more blog posts from us in the future! We would like to write about how to\\nuse certain APIs, design challenges that we encountered while developing the engine, and internal\\nimplementation details.\\nSubscribe to our [RSS feed][feed] if you\'re interested in staying up to date!\\n\\nThis big release was partly possible thanks to those who have [supported us](https://opencollective.com/boa).\\nThanks to funds we\'ve received we have been able to renew our domain name, remunerate members of the\\nteam who have worked on the features released, and discuss the possibility of using dedicated servers\\nfor benchmarking. If you wish to sponsor Boa, you can do so by donating to our [open collective][collective].\\nYou can also check [easy][easy_issues] or [good first issues][first_issues] if you want to contribute\\nsome code instead.\\n\\n[changelog]: https://github.com/boa-dev/boa/blob/v0.18/CHANGELOG.md\\n[conformance]: https://boajs.dev/boa/test262/\\n[feed]: https://boajs.dev/blog/rss.xml\\n[collective]: https://opencollective.com/boa\\n[easy_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3AE-Easy\\n[first_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22\\n\\n<!--truncate-->\\n\\n## Highlights\\n\\n### We\'re on [test262.fyi](https://test262.fyi/)\\n\\nThanks to the amazing work of [CanadaHonk](https://twitter.com/CanadaHonk), Boa is now listed on\\n[test262.fyi](https://test262.fyi/)! This is a daily runner of the official test262 test suite that\\nruns a nightly build of Boa, along with other engines, and updates the results every day. This is\\nusing the tip of the main branch of Boa alongside the [latest test262](https://github.com/tc39/test262)\\nchanges pushed to their main branch.\\n\\nThis is a great achievement for us and we are very proud to be listed alongside other major JavaScript\\nengines. It should be much easier for users to compare Boa\'s conformance tests with other engines.\\n\\n### Temporal\\n\\nA lot of work has been put over the past few months on the Temporal API. The Temporal API is a new\\nset of built-in objects and functions that is designed to be a more modern replacement for the `Date`\\nobject, providing a more feature-rich and flexible API for working with dates and times.\\n\\nIt is currently a [stage 3 proposal](https://tc39.es/proposal-temporal/docs/) and we are working\\nalongside the TC39 champions to put together a solid implementation. Since Temporal is such an\\nextensive specification, we have done most of the work outside of Boa so that it can be used in other\\nprojects. This work can be found in the [temporal_rs](https://github.com/boa-dev/temporal/) repository.\\n\\nWe hope to release a full blog post on Temporal in the future, but for now, let\'s look at a couple small\\nexamples of Temporal.\\n\\nIn JavaScript:\\n\\n```javascript\\n// JavaScript\'s Temporal built-in object.\\n\\n// For example, you can customize you\'re own calendar implementations!\\nclass CustomCalendar extends Temporal.Calendar {\\n  constructor() {\\n    super(\\"iso8601\\");\\n  }\\n  inLeapYear(dateLike) {\\n    messageInACalendar = \\"It\'s a message in a Calendar!\\";\\n    return dateLike.daysInYear === 366;\\n  }\\n}\\n\\nlet messageInACalendar;\\n// Construct the CustomCalendar.\\nconst calendar = new CustomCalendar();\\n\\nconst boaReleaseDay = new Temporal.PlainDate(2024, 3, 7, calendar);\\nconst leap = boaReleaseDay.inLeapYear;\\n\\nmessageInACalendar;\\n// Outputs: \\"It\'s a message in a Calendar!\\"\\n```\\n\\nIn Rust:\\n\\n```rust\\n// Rust\'s `temporal_rs` crate\\nuse temporal_rs::{components::{calendar::CalendarSlot, Date}, options::ArithmeticOverflow };\\nuse std::str::FromStr;\\n\\n// Create a Calendar slot value from a string\\nlet calendar = CalendarSlot::<()>::from_str(\\"iso8601\\").unwrap();\\n\\n// Create a date. The date can be made to either reject or constrain the input.\\nlet date = Date::<()>::new(2024, 3, 7, calendar, ArithmeticOverflow::Reject).unwrap();\\n\\nassert_eq!(date.iso_year(), date.year().unwrap());\\n\\n```\\n\\nPlease note that Temporal is still an experimental feature, and while a lot of progress\\nhas been made, there is still more work to be completed until it is production ready.\\n\\nIf you\'re interested in learning more or want to contribute to the native Rust implementation of\\nTemporal, feel free to check out `temporal_rs`\'s [issues](https://github.com/boa-dev/temporal/issues)!\\n\\n### RegExp\\n\\nOver the past 7 months there has been some effort poured into an improved implementation of RegExp.\\nThis includes:\\n\\n- Support for [`RegExp.prototype.hasIndices`] (Thanks to [@dirkdev98](https://github.com/dirkdev98)!).\\n- Support for Unicode sets, aka the `v` flag.\\n- Support for UTF-16 text searches.\\n- General fixes around `RegExp()`, `RegExp.toString()` and `RegExp.match()`.\\n\\nHere is a table showing the progress of RegExp between v0.17 and v0.18:\\n\\n| Test262 | v0.17 (July 2023) | v0.18 (Feb 2024) |\\n| ------- | ----------------- | ---------------- |\\n| Total   | 1,915             | 1,920            |\\n| Pass    | 1,071             | 1,878            |\\n| Fail    | 132               | 2                |\\n| Skipped | 712               | 40               |\\n\\nThat\'s a whopping 807 more tests passed!\\n\\nWe only have two failing tests left and both are caused by the lack of Unicode 15.1 support.\\nThe remaining skipped tests are all related to stage 3 proposals.\\n\\n[`RegExp.prototype.hasIndices`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/hasIndices\\n\\n### Shared Array Buffer + Atomics\\n\\nThe [SharedArrayBuffer] and [Atomics] builtins have been implemented in this release.\\nThis means embedders can now orchestrate `Context`s running on separate threads to execute\\nshared work between them.\\n\\nThe `Atomics` builtin object contains several static methods that allow executing atomic operations\\non shared memory. In addition to that, it also contains the `wait()` and `notify()` methods, which\\noffers the same functionality as Linux futexes for JS\'s worker threads:\\n\\n```js\\n// On the main thread\\nconst sab = new SharedArrayBuffer(1024);\\nconst int32 = new Int32Array(sab);\\nsend(worker1, int32);\\nsend(worker2, int32);\\n\\n// On worker1\\nint32 = receive();\\nAtomics.wait(int32, 0, 0);\\nconsole.log(int32[0]); // 123\\n\\n// On worker2\\nint32 = receive();\\nconsole.log(int32[0]); // 0\\nAtomics.store(int32, 0, 123);\\nAtomics.notify(int32, 0, 1);\\n```\\n\\n[SharedArrayBuffer]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\\n[Atomics]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics\\n\\n## Intl updates\\n\\nWe\'re keeping the good progress on our `Intl` implementation, and now we have the [`Intl.PluralRules`]\\nbuiltin and (a first prototype of) the [`Intl.NumberFormat`] builtin in place.\\n\\nAs mentioned by the [Mozilla docs][description]:\\n\\n> Languages use different patterns for expressing both plural numbers of items (cardinal numbers) and\\n> for expressing the order of items (ordinal numbers). English has two forms for expressing cardinal\\n> numbers: one for the singular \\"item\\" (1 hour, 1 dog, 1 fish) and the other for zero or any other\\n> number of \\"items\\" (0 hours, 2 lemmings, 100000.5 fish), while Chinese has only one form, and Arabic\\n> has six! Similarly, English has four forms for expressing ordinal numbers: \\"th\\", \\"st\\", \\"nd\\", \\"rd\\",\\n> giving the sequence: 0th, 1st, 2nd, 3rd, 4th, 5th, ..., 21st, 22nd, 23rd, 24th, 25th, and so on,\\n> while both Chinese and Arabic only have one form for ordinal numbers.\\n\\nThis variation between languages makes it really hard to properly localize a cardinal or ordinal number.\\nTo fix this, the CLDR (Common Locale Data Repository) project has been collecting information about\\nthe \\"plural category\\" of certain numeric patterns on many languages, and `Intl.PluralRules` objects\\nare the builtin objects that enable obtaining this information in an easy way:\\n\\n```js\\nconst pr = new Intl.PluralRules(\\"en-US\\", { type: \\"ordinal\\" });\\n\\nconst suffixes = new Map([\\n  [\\"one\\", \\"st\\"],\\n  [\\"two\\", \\"nd\\"],\\n  [\\"few\\", \\"rd\\"],\\n  [\\"other\\", \\"th\\"],\\n]);\\n\\nconst getSuffix = (n) => {\\n  return suffixes.get(pr.select(n));\\n};\\n\\nconsole.log(getSuffix(0)); // \\"th\\"\\nconsole.log(getSuffix(1)); // \\"st\\"\\nconsole.log(getSuffix(2)); // \\"nd\\"\\nconsole.log(getSuffix(3)); // \\"rd\\"\\nconsole.log(getSuffix(4)); // \\"th\\"\\n\\nconsole.log(getSuffix(21)); // \\"st\\"\\nconsole.log(getSuffix(42)); // \\"nd\\"\\nconsole.log(getSuffix(73)); // \\"th\\"\\n```\\n\\nOn the same vein, [`Intl.NumberFormat`] objects can format numbers in a language-sensitive way:\\n\\n```js\\nconst nf = new Intl.NumberFormat(\\"bn\\", {\\n  useGrouping: \\"min2\\",\\n  minimumSignificantDigits: 3,\\n  maximumSignificantDigits: 7,\\n});\\n\\nconsole.log(nf.format(10003.1234)); // à§§à§¦,à§¦à§¦à§©.à§§à§¨\\n```\\n\\nHowever, we need to mention that `Intl.NumberFormat` is NOT feature complete at the moment, since it\\nonly allows formatting numbers in the standard notation with no currencies or units. We\'re still\\nworking on adding the missing features, but we hope that this initial prototype is at least useful\\nfor some use cases.\\n\\n[`Intl.PluralRules`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/PluralRules\\n[`Intl.NumberFormat`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat\\n[description]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/PluralRules#description\\n\\n## Builtins updates\\n\\nWhile this new release is filled with shiny new features and APIs, it should be noted that the\\nECMAScript 262 specification is constantly evolving, which is why there are also a lot of small\\nchanges and additions to existing builtins that keep Boa updated to the latest revisions of the\\nspecification.\\n\\nAll examples were taken from the [Mozilla Web Docs](https://developer.mozilla.org/en-US).\\n\\n### [findLast and findLastIndex on TypedArray](https://github.com/boa-dev/boa/pull/3135)\\n\\n```js\\nfunction isPrime(element) {\\n  if (element % 2 === 0 || element < 2) {\\n    return false;\\n  }\\n  for (let factor = 3; factor <= Math.sqrt(element); factor += 2) {\\n    if (element % factor === 0) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\nlet uint8 = new Uint8Array([4, 6, 8, 12]);\\nconsole.log(uint8.findLast(isPrime)); // undefined (no primes in array)\\nuint8 = new Uint8Array([4, 5, 7, 8, 9, 11, 12]);\\nconsole.log(uint8.findLast(isPrime)); // 11\\n```\\n\\n### [String.prototype.isWellFormed and String.prototype.toWellFormed](https://github.com/boa-dev/boa/pull/3187)\\n\\n```js\\nconst illFormed = \\"https://example.com/search?q=\\\\uD800\\";\\n\\ntry {\\n  encodeURI(illFormed);\\n} catch (e) {\\n  console.log(e); // URIError: URI malformed\\n}\\n\\nif (illFormed.isWellFormed()) {\\n  console.log(encodeURI(illFormed));\\n} else {\\n  console.warn(\\"Ill-formed strings encountered.\\"); // Ill-formed strings encountered.\\n}\\n```\\n\\n### [Change Array by copy](https://github.com/boa-dev/boa/pull/3412)\\n\\n```js\\nconst months = [\\"Mar\\", \\"Jan\\", \\"Feb\\", \\"Dec\\"];\\nconst sortedMonths = months.toSorted();\\nconsole.log(sortedMonths); // [\'Dec\', \'Feb\', \'Jan\', \'Mar\']\\nconsole.log(months); // [\'Mar\', \'Jan\', \'Feb\', \'Dec\']\\n\\nconst values = [1, 10, 21, 2];\\nconst sortedValues = values.toSorted((a, b) => a - b);\\nconsole.log(sortedValues); // [1, 2, 10, 21]\\nconsole.log(values); // [1, 10, 21, 2]\\n```\\n\\n### [Grouping functions](https://github.com/boa-dev/boa/pull/3420)\\n\\n```js\\nconst array = [1, 2, 3, 4, 5];\\n\\n// `Object.groupBy` groups items by arbitrary key.\\n// In this case, we\'re grouping by even/odd keys\\nObject.groupBy(array, (num, index) => {\\n  return num % 2 === 0 ? \\"even\\" : \\"odd\\";\\n});\\n// =>  { odd: [1, 3, 5], even: [2, 4] }\\n\\n// `Map.groupBy` returns items in a Map, and is useful for grouping\\n// using an object key.\\nconst odd = { odd: true };\\nconst even = { even: true };\\nMap.groupBy(array, (num, index) => {\\n  return num % 2 === 0 ? even : odd;\\n});\\n// =>  Map { {odd: true}: [1, 3, 5], {even: true}: [2, 4] }\\n```\\n\\n### [Resizable buffers](https://github.com/boa-dev/boa/pull/3634)\\n\\n```js\\nconst buffer = new ArrayBuffer(8, { maxByteLength: 16 });\\n\\nconsole.log(buffer.byteLength); // 8\\n\\nbuffer.resize(12);\\n\\nconsole.log(buffer.byteLength); // 12\\n```\\n\\n### [Transferrable buffers](https://github.com/boa-dev/boa/pull/3649)\\n\\n```js\\nconst buffer = new ArrayBuffer(8, { maxByteLength: 16 });\\nconst view = new Uint8Array(buffer);\\nview[1] = 2;\\nview[7] = 4;\\n\\n// Copy the buffer to a smaller size\\nconst buffer2 = buffer.transfer(4);\\nconsole.log(buffer2.byteLength); // 4\\nconsole.log(buffer2.maxByteLength); // 16\\nconst view2 = new Uint8Array(buffer2);\\nconsole.log(view2[1]); // 2\\nconsole.log(view2[7]); // undefined\\nbuffer2.resize(8);\\nconsole.log(view2[7]); // 0\\n\\n// Copy the buffer to a larger size within maxByteLength\\nconst buffer3 = buffer2.transfer(12);\\nconsole.log(buffer3.byteLength); // 12\\n\\n// Copy the buffer to a larger size than maxByteLength\\nbuffer3.transfer(20); // RangeError: Invalid array buffer length\\n```\\n\\n## APIs updates\\n\\n### Experimental features\\n\\nSome of you might have noticed that the previous section contained a builtin addition that isn\'t\\ntechnically a \\"spec addition\\", but a \\"proposal for a spec addition\\". To clarify, the\\n[`ArrayBuffer.prototype.transfer` and friends][transfer] proposal is, at the time of the publication\\nof this post, still at stage 3 on the [TC39 Process]. Generally, stages 3 and below need to be\\ngated by implementors; this avoids exposing experimental APIs to users.\\n\\nMirroring this general idea, we introduced a new `experimental` feature for the `boa_engine` crate.\\nEnabling this feature will make it possible to test future proposals for the ECMAScript specification\\nusing Boa, but we do not recommend enabling the feature in production environments.\\n\\nWe\'re still trying to [find a way to enable experimental features in a more granular way][feats],\\nsince the current flag allows enabling either all or no experimental features; definitely not ideal.\\nSo, expect some API changes in the future around this. But for now, have fun testing the new proposals!\\n\\n[transfer]: https://github.com/tc39/proposal-arraybuffer-transfer\\n[TC39 Process]: https://tc39.es/process-document/\\n[feats]: https://github.com/boa-dev/boa/issues/3377\\n\\n### `[[HostDefined]]` fields\\n\\nIn this version, we introduced a new API to attach custom data to realms, scripts and modules.\\nThe [`HostDefined`] struct is a more composable way of attaching custom data. Instead of attaching\\nonly a single type casted to an `Any`, you can insert many types to the `HostDefined` map, and\\nevery separate type will have its own value stored inside the map.\\n\\n```rust\\n// Example snippet taken from https://github.com/boa-dev/boa/blob/main/examples/src/bin/host_defined.rs\\n// Check that file for a more extensive example.\\n\\n/// Custom host-defined struct that has some state, and can be shared between JavaScript and rust.\\n#[derive(Default, Trace, Finalize, JsData)]\\nstruct CustomHostDefinedStruct {\\n    #[unsafe_ignore_trace]\\n    counter: usize,\\n}\\n\\n// We create a new `Context` to create a new Javascript executor.\\nlet mut context = Context::default();\\n\\n// Get the realm from the context.\\nlet realm = context.realm().clone();\\n\\n// Insert a default CustomHostDefinedStruct.\\nrealm\\n    .host_defined_mut()\\n    .insert_default::<CustomHostDefinedStruct>();\\n\\nassert!(realm.host_defined().has::<CustomHostDefinedStruct>());\\n\\n// Get the [[HostDefined]] field from the realm and downcast it to our concrete type.\\nlet host_defined = realm.host_defined();\\nlet Some(host_defined) = host_defined.get::<CustomHostDefinedStruct>() else {\\n    return Err(JsNativeError::typ()\\n    .with_message(\\"Realm does not have HostDefined field\\")\\n    .into());\\n};\\n\\n// Assert that the [[HostDefined]] field is in it\'s initial state.\\nassert_eq!(host_defined.counter, 0);\\n\\n```\\n\\n[`HostDefined`]: https://docs.rs/boa_engine/0.18.0/boa_engine/struct.HostDefined.html\\n\\n### `Class` redesign + API enhancements\\n\\nThere were some small improvements made to our `Class` trait API, including a way to cache\\ncustom `Class` implementors into the `Context` itself for easy access to the constructor and\\nprototype objects. This is part of an ongoing effort about\\n[improving the APIs around the `Class` trait][class].\\n\\n```rust\\n// An example of what this new API allows\\n// Assume there\'s already a `Person` struct that implements `Class`.\\n\\nlet mut context = Context::default();\\ncontext\\n  .register_global_class::<Person>()\\n  .expect(\\"the Person builtin shouldn\'t exist\\");\\n\\n// Previously, the line below had to be done manually using something like\\n// let prototype = context\\n//     .global_object()\\n//     .get(js_string!(\\"Person\\"), context)\\n//     .unwrap()\\n//     .as_object()\\n//     .cloned()\\n//     .unwrap()\\n//     .get(js_string(\\"prototype\\"), context)\\n//     .unwrap()\\n//     .as_object()\\n//     .cloned()\\n//     .unwrap();\\n// Yeah... it\'s a handful.\\nlet prototype = context.get_global_class::<Person>().unwrap().prototype();\\n```\\n\\n[class]: https://github.com/boa-dev/boa/issues/3314\\n\\n### Runtime limits\\n\\nWe added new APIs to limit the execution of the engine at runtime! This new API has some limitations\\nsuch as being unable to track limits inside native Rust functions, and we\'re still working on offering\\nmore options for other runtime limits such as heap size limits, but we hope this is at least useful\\nfor some users.\\n\\n```rust\\n// Snippet taken from https://github.com/boa-dev/boa/blob/main/examples/src/bin/runtime_limits.rs\\n// Check that file for the full example.\\n// Create the JavaScript context.\\nlet mut context = Context::default();\\n\\n// Set the context\'s runtime limit on loops to 10 iterations.\\ncontext.runtime_limits_mut().set_loop_iteration_limit(10);\\n\\n// Here we exceed the limit by 1 iteration and a `RuntimeLimit` error is thrown.\\n//\\n// This error cannot be caught in JavaScript, it can only be caught in Rust code.\\nlet result = context.eval(Source::from_bytes(\\n    r\\"\\n        try {\\n            for (let i = 0; i < 12; ++i) { }\\n        } catch (e) {\\n\\n        }\\n    \\",\\n));\\nassert!(result.is_err());\\n```\\n\\n### Synthetic modules\\n\\nWe added support for creating synthetic modules from Rust code. This allows exposing a set of\\nfunctions and properties to other modules without having to evaluate Javascript code.\\n\\n```rust\\n// Taken from https://github.com/boa-dev/boa/blob/main/examples/src/bin/synthetic.rs\\n// See the file for the full example.\\n\\n// ...\\n\\nlet sum = FunctionObjectBuilder::new(\\n        context.realm(),\\n        NativeFunction::from_fn_ptr(|_, args, ctx| {\\n            args.get_or_undefined(0).add(args.get_or_undefined(1), ctx)\\n        }),\\n    )\\n    .length(2)\\n    .name(js_string!(\\"sum\\"))\\n    .build();\\n\\n// ...\\n\\nlet operations = Module::synthetic(\\n    // Make sure to list all exports beforehand.\\n    &[\\n        js_string!(\\"sum\\"),\\n        // ...\\n    ],\\n    // The initializer is evaluated every time a module imports this synthetic module,\\n    // so we avoid creating duplicate objects by capturing and cloning them instead.\\n    SyntheticModuleInitializer::from_copy_closure_with_captures(\\n        |module, fns, _| {\\n            println!(\\"Running initializer!\\");\\n            module.set_export(&js_string!(\\"sum\\"), fns.0.clone().into())?;\\n            // ...\\n            Ok(())\\n        },\\n        (sum, /* ... */),\\n    ),\\n    None,\\n    context,\\n)\\n\\nloader.insert(\\n    PathBuf::from(\\"./scripts/modules\\")\\n        .canonicalize()?\\n        .join(\\"operations.mjs\\"),\\n    operations,\\n);\\n\\n// ...\\n\\n```\\n\\n### Async eval\\n\\nDue to popular demand, we added some APIs that allow running scripts in an asynchronous way, making\\nit possible to share some workload between async tasks and the execution of the engine itself.\\nNote that, by the single-threaded nature of JS engines, all futures returned by Boa cannot implement\\nneither `Send` nor `Sync`.\\n\\n```rust\\nlet context = &mut Context::default();\\nlet src = Source::from_bytes(r#\\"\\n  let array = new Array([15, 20, 35, 123, 65, 12]);\\n  array.sort();\\n  console.log(array);\\n\\"#);\\nlet src = Script::parse(src, None, context).unwrap();\\nlet task = async move {\\n  let result = src.evaluate_async(context).await.unwrap();\\n  println!(\\"{:?}\\", result.display());\\n}\\nblock_on(join!(long_task(), task));\\n\\n```\\n\\n### `JsErasedError`\\n\\nDon\'t you hate when you try to `?` a `Result<T, JsError>` and the compiler just complains saying\\nsomething like\\n\\n```rust\\nerror[E0277]: `Rc<num_bigint::bigint::BigInt>` cannot be sent between threads safely\\n   --> tests/tester/src/main.rs:190:52\\n    |\\n190 |     Context::default().eval(Source::from_bytes(\\"\\"))?;\\n    |                                                    ^ `Rc<num_bigint::bigint::BigInt>` cannot be sent between threads safely\\n    |\\n    = help: within `JsError`, the trait `Send` is not implemented for `Rc<num_bigint::bigint::BigInt>`\\n    = help: the following other types implement trait `FromResidual<R>`:\\n              <Result<T, F> as FromResidual<Yeet<E>>>\\n              <Result<T, F> as FromResidual<Result<Infallible, E>>>\\n```\\n\\nWell, say no more to missing `Send`s in your daily life! We present to you, `JsErasedError`!\\n\\nJokes aside, using `JsError` is difficult from an embedder\'s perspective because `JsError` can be\\nany arbitrary value, including non-`Send` values such as `JsObject`, `JsString` or `JsBigInt`.\\nThis makes `JsError` automatically incompatible with libraries like `anyhow` or `eyre` that expect\\nonly `Send` errors.\\n\\nTo solve this, we introduced a new `JsError::into_erased` method which returns a thread-safe\\nversion of `JsError` that is compatible with `anyhow`, `eyre` and other error-reporting libraries.\\n\\n```rust\\nfn main() -> eyre::Result<()> {\\n    let context = &mut Context::default();\\n    let value = context\\n        .eval(Source::from_bytes(\\"\\"))\\n        .map_err(|err| err.into_erased(context))?; // No compiler errors!\\n}\\n```\\n\\nWhy not call it `JsSendError` instead of `JsErasedError`? Well, it is generally not possible to\\nconvert a `JsError` into a `JsErasedError` without losing some information in the conversion. However,\\n`JsSendError` gave the appearance of being `JsError` but `Send`, which is really not true. `JsErasedError`,\\non the other hand, makes it clear the conversion is not lossless. Feel free to ping us if you have a\\nbetter name for it though!\\n\\n## Optimizations\\n\\nThe following benchmarks below are taken from the [v8 benchmark suite]. This benchmark is deprecated,\\nbut is useful in this context to show the performance improvements between versions.\\n\\n(higher numbers are better)\\n\\n| Boa Version | Richards | DeltaBlue | Crypto | RayTrace | EarleyBoyer | Splay | NavierStokes | Total |\\n| ----------- | -------- | --------- | ------ | -------- | ----------- | ----- | ------------ | ----- |\\n| v0.16       | 29.0     | 29.2      | 42.1   | 107      | 105         | 111   | 15.4         | 49.1  |\\n| v0.17       | 34.3     | 39.1      | 49.1   | 134      | 119         | 141   | 11.9         | 56.2  |\\n| v0.18       | 49.8     | 53.9      | 52.1   | 161      | 152         | 154   | 102          | 91.5  |\\n\\n[v8 benchmark suite]: https://github.com/mozilla/arewefastyet/tree/master/benchmarks/v8-v7\\n\\n### Inline Caching\\n\\nThanks to the implementation of [Object Shapes](https://github.com/boa-dev/boa/blob/main/docs/shapes.md)\\nin version `v0.17`, we were able to further improve the performance of the engine by implementing\\nInline Caching. The concept of Inline Caching is based on the idea that a property access for a\\nvariable will usually only be applied to objects of similar Shapes. To picture this, let\'s examine\\nthe following code:\\n\\n```js\\nfunction attach(obj1, obj2) {\\n  obj1.attach = obj2.getHandler();\\n}\\n```\\n\\nOn interpreters that don\'t implement any kind of caching, the previous code would have to make a\\nproperty lookup for the `getHandler` method every time that method is called. This is really inefficient\\nfor a simple reason: `getHandler` could be inside `obj2`, or it could be inside `obj2.prototype`,\\nor it could be inside `obj2.prototype.prototype`... in fact, `getHandler` could be anywhere on the\\ninheritance chain of `obj2`!\\n\\nThe easy approach to solve this is to cache the method lookup inside `obj2` itself using an associative\\nmap of some sorts. This is nice, but also a bit wasteful because we would be allocating a new\\nassociative map for all instances of `obj2`, even if the map is only really used inside `attach`.\\n\\nWhat then? Well, we can apply the \\"inline\\" part of an inline cache now! Just allocate an array of\\nall property accesses within the `attach` function and assign an index to every one of them.\\nInitially, a property access is uninitialized. Once we reach a particular uninitialized property access,\\nit performs the dynamic lookup and changes its corresponding array slot to be a\\nweak reference to the object\'s shape. If we reach the same property access again, we can retrieve the\\nstored shape and directly access the object\'s dense storage without doing a property lookup!\\n\\nHowever, there\'s a caveat. If `obj2.getHandler` is evaluated twice with objects of different shapes,\\nthe stored shape would be invalid for the second property access. In this case, we can rollback the\\naccess to the uninitialized state and make a manual property lookup once again.\\nThis is known as monomorphic inline caching. There\'s also polymorphic inline caching, which\\nstores several shapes per access instead of rolling back to the uninitialized state.\\n\\nCurrently we do eager monomorphic inline caching, so there is plently of room for improvements that\\nwe\'re planning to do in the future!\\n\\n## Road to 1.0\\n\\nAs Boa is being used by more projects it is important we can provide a stable and reliable API. We\\ndon\'t feel like we\'re quite there yet, but after a discussion with the team we have decided to aim\\nfor a 1.0 release in the near future. This will be a big milestone for us and we hope to have a lot\\nof new features and improvements to show off by then.\\n\\nWe will keep our focus on the public API for those embedding Boa. We will also be working on improving\\nthe performance of the engine. If you wanted to offer feedback on the API feel free to reach out to\\nus via Github or Discord.\\n\\nYou can keep an eye on the project to reach 1.0 [here](https://github.com/orgs/boa-dev/projects/2/views/1).\\nWe hopefully don\'t forsee this project getting much bigger as most issues such as spec conformance\\nor performance are a going-concern.\\n\\n## Conclusion\\n\\n### How can you support Boa?\\n\\nBoa is an independent JavaScript engine implementing the ECMAScript specification, we rely on the\\nsupport of the community to keep it going. If you want to support us, you can do so by donating to\\nour [open collective]. Proceeeds here go towards this very website, the domain name, and remunerating\\nmembers of the team who have worked on the features released.\\n\\nIf financial contribution is not your strength, you can contribute by asking to be assigned to one of\\nour [open issues], and asking for mentoring if you don\'t know your way around the engine. Our\\n[contribution guide] should help you here. If you are more used to working with JavaScript or frontend\\nweb development, we also welcome help to improve our web presence, either in [our website], or in our\\n[testing representation] page or benchmarks page. You can also contribute to our Criterion benchmark\\ncomparison GitHub [action].\\n\\nWe are also looking to improve the documentation of the engine, both for developers of the engine\\nitself and for users of the engine. Feel free to contact us in [Discord].\\n\\n[open collective]: https://opencollective.com/boa\\n[open issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+no%3Aassignee\\n[contribution guide]: https://github.com/boa-dev/boa/blob/main/CONTRIBUTING.md\\n[our website]: https://github.com/boa-dev/boa-dev.github.io\\n[testing representation]: https://github.com/boa-dev/boa/issues/820\\n[action]: https://github.com/boa-dev/criterion-compare-action\\n[Discord]: https://discord.gg/tUFFk9Y\\n\\n### Thank You\\n\\nOnce again, big thanks to [all the contributors][contributors] of this release!!\\n\\n[contributors]: https://github.com/boa-dev/boa/graphs/contributors?from=2023-07-08&to=2024-03-05&type=c"},{"id":"/2023/07/08/boa-release-17","metadata":{"permalink":"/blog/2023/07/08/boa-release-17","source":"@site/blog/2023-07-08-boa-release-17.md","title":"Boa release v0.17","description":"Summary","date":"2023-07-08T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":12.88,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.17","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.18","permalink":"/blog/2024/03/07/boa-release-18"},"nextItem":{"title":"Adding a JavaScript interpreter to your Rust project","permalink":"/blog/2022/10/24/boa-usage"}},"content":"## Summary\\n\\nBoa v0.17 is now available! This is one of the biggest Boa releases since the project started, and after around 7 months\\nof development, we are very happy to present you the latest release of the Boa JavaScript engine. Boa makes it easy to\\nembed a JS engine in your projects, and you can even use it from WebAssembly. See the [about](/about) page for more info.\\n\\nIn this release, our conformance has grown from 74.53% to 78.74% in the official ECMAScript Test Suite (Test262). While\\nthis might look as a small increase, we now pass **6,079** more tests than in the previous version. In any case, the big\\nchanges in this release are not related to conformance, but to huge internal enhancements and new APIs that you will be\\nable to use.\\n\\nYou can check the full list of changes [here][changelog], and the full information on conformance [here][conformance].\\n\\nMoreover, this big release was partly possible thanks to a grant by [Lit Protocol](https://litprotocol.com/). Thanks to\\nthis grant, we were able to remunerate 2 team members for their 20h/week work each during three and a half months. If\\nyou wish to sponsor Boa, you can do so by donating to our [open collective][collective]. You can also check\\n[easy][easy_issues] or [good first issues][first_issues].\\n\\nFurthermore, we now have a new domain for Boa, [boajs.dev][boajs].\\n\\n[changelog]: https://github.com/boa-dev/boa/blob/v0.17/CHANGELOG.md\\n[conformance]: https://boajs.dev/boa/test262/\\n[collective]: https://opencollective.com/boa\\n[easy_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3AE-Easy\\n[first_issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22\\n[boajs]: https://boajs.dev\\n\\n<!--truncate-->\\n\\n## Highlights\\n\\n### Modules\\n\\nBoa finally has a module system! This implementation tries to closely follow ECMAScript\'s [**Modules**][modules]\\nspecification which includes some useful hooks to customize module loading, making it possible to load modules from\\nseveral sources, fetch modules from an URL and even asynchronously load and parse them to avoid blocking execution; see\\nthe [`ModuleLoader`][mod_loader] for more information.\\n\\nWe also implemented a simple loader (currently the default module loader), which should fulfill most of the simpler use cases:\\n\\n```rust\\n// Creates a new module loader that uses the current directory to resolve module imports.\\nlet loader = &SimpleModuleLoader::new(Path::new(\\".\\")).unwrap();\\n\\n// Need to convert it to either a `&dyn ModuleLoader` or a `Rc<dyn ModuleLoader>` in order\\n// to pass it to the context.\\nlet dyn_loader: &dyn ModuleLoader = loader;\\nlet mut context = &mut Context::builder().module_loader(dyn_loader).build().unwrap();\\n\\nlet source = Source::from_bytes(\\"1 + 3\\");\\n\\nlet module = Module::parse(source, None, context).unwrap();\\n\\n// `main.mjs` or any of its imports could import `main.mjs` itself, so we\\n// insert it into the loader for good measure.\\nloader.insert(Path::new(\\"main.mjs\\").to_path_buf(), module.clone());\\n\\n// All modules use promises to signal completion of its lifecycle.\\n// The utility method `load_link_evaluate` calls `load`, then `link` and\\n// finally `evaluate`, returning an error if any call fails.\\nlet promise = module.load_link_evaluate(context).unwrap();\\n\\n// Important to push the job queue forward! Otherwise, the modules won\'t progress\\n// on their lifecycle.\\ncontext.run_jobs();\\n\\n// All modules return `undefined` if they\'re successfully evaluated.\\nassert_eq!(promise.state().unwrap(), PromiseState::Fulfilled(JsValue::undefined()));\\n```\\n\\nFor a more extensive, descriptive example that uses a real directory, you can check out [**boa_examples**][mod_example].\\n\\n[modules]: https://tc39.es/ecma262/#sec-modules\\n[mod_loader]: https://docs.rs/boa_engine/0.17.0/boa_engine/module/trait.ModuleLoader.html\\n[mod_example]: https://github.com/boa-dev/boa/blob/v0.17/boa_examples/src/bin/modules.rs\\n\\n### Spec Version Conformance\\n\\nSomething we get asked a lot is _\\"Do you support ES5 or ES6\\"_? or _\\"How far away are you from supporting ESX\\"_?\\nWe\'re pleased to say we\'ve updated our conformance board to show you how we\'re doing across ES versions.\\n\\nJust navigate to our [Test262 Dashboard][conformance], select \\"Test Results\\" on our main branch, and\\nthen you can use the dropdown underneath to see how we\'re doing on each version. ES5 and ES6 are very close, you can see\\nwe\'re only a few tests away from them being fully implemented.\\n\\n### Optimizations\\n\\n#### Constant folding optimization\\n\\nConstant folding expression is a powerful compiler optimization technique that significantly enhances the efficiency and\\nperformance of compiled programs. This optimization, now incorporated in the latest release, aims to reduce runtime\\noverhead by evaluating constant expressions at compile-time.\\n\\nWith constant folding expression optimization, the compiler analyzes expressions involving constants and replaces them\\nwith their computed results. This process allows the compiler to transform arithmetic operations, comparisons, and\\nlogical expressions into simplified forms, removing unnecessary runtime computations. By eliminating these computations,\\nthe optimized program benefits from reduced execution time and improved overall performance.\\n\\n#### Object Shapes (Hidden classes)\\n\\nHidden Classes (called \\"Shapes\\" internally to avoid confusion with JavaScript classes) are an alternative way to\\nstructure objects that stores the property keys (string or symbol) (i.e. `object.propertyName`) and its attributes\\n(writable, enumerable, configurable) as transitions from a root shape, and the values as a dense array. This is\\ndifferent from the traditional way of storing properties as a hashmap from property keys to values.\\n\\nThe shapes create a transition tree, where the transitions are property names and prototype changes starting from a root\\nshape (no properties, no prototype).\\n\\n```javascript\\nlet o = {} // Shape 1: prototype `Object.prototype` and properties: empty\\no.a = 10   // Shape 2: prototype `Object.prototype` and properties: \'a\'\\no.b = 20   // Shape 3: prototype `Object.prototype` and properties: \'a\', \'b\'\\n\\nlet o2 = { a: 30; } // Shape 2: prototype `Object.prototype` and properties: \'a\'\\no2.d = 50           // Shape 4: prototype `Object.prototype` and properties: \'a\', \'d\' -- fork from shape 2\\n```\\n\\nThis separation of property keys and values allows for objects with the same property names to share the same shape,\\nwhich reduces memory consumption and unlocks the possibility for other optimizations such as inline caching.\\n\\nNote: When creating objects with the same property keys, it\'s best to create them in the same order, this ensures that\\nthe objects share the same shape.\\n\\nFor a more in depth explanation of how shared shapes work in boa see `shapes.md`\\n[here](https://github.com/boa-dev/boa/blob/v0.17/docs/shapes.md).\\n\\n### Debug object\\n\\nThe `$boa` debug object has been implemented for convenient JavaScript debugging using Boa\'s CLI interface. If you want\\nto use it, you will need to run the Boa CLI / REPL with the `--debug-object` command line flag.\\n\\nThe `$boa` debug object is divided into modules, so that you can trigger the garbage collection with `$boa.gc.collect()`,\\nor get the bytecode of a function by running `$boa.function.bytecode(fn_name)`. You can also trace function invocations,\\nhandle compiler optimizations, set runtime limits and inspect object shapes.\\n\\nYou can find all the documentation [here][debug_object].\\n\\n[debug_object]: https://github.com/boa-dev/boa/blob/v0.17/docs/boa_object.md\\n\\n### New APIs\\n\\nWe have added new built-in object wrappers, such as [`JsPromise`][js_promise], [`JsRegExp`][js_regexp],\\n[`JsGenerator`][js_generator], [`JsDate`][js_date] and [`JsDataView`][js_data_view]. You can check all of them\\n[here][wrappers].\\n\\nWe also want to present you a new trait that we have developed to make it easier for you to interoperate between Rust\\nand JavaScript: [`TryFromJs`][try_from_js]. All built-ins and Rust basic types that exist in JavaScript implement this\\ntrait, and it adds a new static method to them that allows you to convert a [`JsValue`][js_value] into a Rust structure.\\nYou can also convert any `JsValue` to a `TryFromJs` Rust type with [`JsValue::try_js_into()`][try_js_into] function.\\n\\n```rust\\nlet js_str = r#\\"\\nlet x = /[a-z0-9]@[a-z0-9]/;\\nx;\\n\\"#;\\n\\nlet js = Source::from_bytes(js_str);\\nlet mut context = Context::default();\\nlet res = context.eval(js).unwrap();\\n\\nlet rs_regexp: JsRegExp = res.try_js_into(context).unwrap();\\n\\nlet test_result = rs_regexp.test(\\"hello@domain\\", context)?;\\nassert!(test_result);\\n```\\n\\nMoreover, you can derive `TryFromJs` for any Rust structure, and in the case that you want to manually convert some of\\nthe struct attributes, you can override it:\\n\\n```rust\\n/// Converts the value lossly.\\nfn lossy_conversion(value: &JsValue, _context: &mut Context) -> JsResult<i16> {\\n    match value {\\n        JsValue::Rational(r) => Ok(r.round() as i16),\\n        JsValue::Integer(i) => Ok(*i as i16),\\n        _ => Err(JsNativeError::typ().with_message(\\"cannot convert value to an i16\\").into()),\\n    }\\n}\\n\\n#[derive(Debug, TryFromJs)]\\nstruct TestStruct {\\n    inner: bool,\\n    hello: String,\\n    // You can override the conversion of an attribute.\\n    #[boa(from_js_with = \\"lossy_conversion\\")]\\n    my_float: i16,\\n}\\n\\nlet js_str = r#\\"\\nlet x = {\\n    inner: false,\\n    hello: \\"World\\",\\n    my_float: 2.9,\\n};\\nx;\\n\\"#;\\nlet context = &mut Context::default();\\nlet result = context.eval(Source::from_bytes(js_str))?;\\nlet str = TestStruct::try_from_js(&result, context)?;\\n\\nprintln!(\\"{str:?}\\");\\n```\\n\\n#### Source API\\n\\nWe have introduced a new `Source API` to Boa. The new API represents JavaScript stored from a path or `None` if it\'s\\ncoming from a plain string.\\n\\nThis change improves the display of `boa_tester` to show the path of the tests being run. It also enables hyperlinks to\\ndirectly jump to the tested file from the VS terminal. This will further help with error displays and debugging in the\\nfuture.\\n\\n```rust\\nuse boa_engine::{Context, Source};\\n\\nfn main() {\\n    let js_file_path = \\"./scripts/helloworld.js\\";\\n\\n    match Source::from_filepath(Path::new(js_file_path)) {\\n    ...\\n```\\n\\nSee Boa\'s [examples](https://github.com/boa-dev/boa/tree/v0.17/boa_examples/src/bin) for more examples on how its used.\\n\\n#### Hooks and Job Queues\\n\\nIn this release we have added `HostHooks` and `JobQueue` traits to `Context`. This will allow hosts to implement custom\\nevent loops and other host specific functionality. This makes Boa more configurable for users and any future runtimes\\nwhich need to add a more complex event loop, such as Tokio or Mio.\\n\\nAs a result of this change, Boa\'s CLI will run all jobs until the queue is empty, even if a Job returns an `Err`.`\\n\\n[js_promise]: https://docs.rs/boa_engine/0.17.0/boa_engine/object/builtins/struct.JsPromise.html\\n[js_regexp]: https://docs.rs/boa_engine/0.17.0/boa_engine/object/builtins/struct.JsRegExp.html\\n[js_generator]: https://docs.rs/boa_engine/0.17.0/boa_engine/object/builtins/struct.JsGenerator.html\\n[js_date]: https://docs.rs/boa_engine/0.17.0/boa_engine/object/builtins/struct.JsDate.html\\n[js_data_view]: https://docs.rs/boa_engine/0.17.0/boa_engine/object/builtins/struct.JsDataView.html\\n[wrappers]: https://docs.rs/boa_engine/0.17.0/boa_engine/object/builtins/index.html\\n[try_from_js]: https://docs.rs/boa_engine/0.17.0/boa_engine/value/trait.TryFromJs.html\\n[try_js_into]: https://docs.rs/boa_engine/0.17.0/boa_engine/enum.JsValue.html#method.try_js_into\\n\\n### New Builtins\\n\\n#### `Intl`\\n\\nBoa now has internationalization support! Although we are still working on full compliance with the\\n[`ecma402` specification][402], we have a couple of `Intl` utilities in place:\\n\\n- [`Intl.Collator`][collator]\\n- [`Intl.ListFormat`][list]\\n- [`Intl.Locale`][locale]\\n- [`Intl.Segmenter`][segmenter]\\n\\nInternationalization data can be pretty expensive at times: the default data included by Boa is 10.6 MB, which is why\\nwe allow customizing the data provider used by the engine with the `ContextBuilder::icu_provider` hook.\\nFor more information on how to generate custom internationalization data, you can check out the\\n[**data management tutorial**][data] from [`icu4x`], the internationalization library used in Boa. Shoutout to the\\n`icu4x` team, who are the ones that made all of this possible!\\n\\nAdditionally, we added an `intl` feature flag, which is enabled by default but can be disabled to reduce Boa\'s binary\\nsize.\\n\\n[402]: https://tc39.es/ecma402/\\n[collator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator\\n[list]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat\\n[locale]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator\\n[segmenter]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter\\n[data]: https://github.com/unicode-org/icu4x/blob/main/docs/tutorials/data_management.md#data-management-in-icu4x\\n[`icu4x`]: https://github.com/unicode-org/icu4x\\n\\n#### `WeakRef`, `WeakSet` and `WeakMap`\\n\\nWe\'ve implemented support for weak references to garbage collected objects. This allowed us to implement some builtins\\nlike [`WeakRef`][wr], [`WeakSet`][ws] and [`WeakMap`][wm]. However, garbage collectors are unpredictable! A garbage\\ncollector could collect at unexpected moments, extend the lifetime of unreachable objects and even leak, which is why\\n[mozilla recommends avoiding using those builtins where possible][moz].\\n\\n[wr]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/WeakRef\\n[ws]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\\n[wm]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\\n[moz]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef#avoid_where_possible\\n\\n### Fuzzing\\n\\nThis release of Boa contains new functionalities in the `boa_ast` crate to support grammar aware fuzzing. The visitor\\npattern that is implemented for the AST makes it easy to traverse the AST and either collect information or apply\\nmodifications. In addition to the fuzzer, we also use the visitor pattern in multiple syntax directed operations. The\\nAST now implements the `Arbitrary` trait from the [`Arbitrary`][arbitrary] crate to generate inputs for fuzzers. Based\\non these features we currently have three fuzzers targeting the parser, bytecompiler and vm. The fuzzers have already\\nhelped us finding multiple panics that we previously had no tests for.\\n\\nWe want to extend a huge thanks to [@addisoncrump](https://github.com/addisoncrump) as they have contributed not only\\nthe fuzzers but also the visitor pattern implementation and the additional bits needed to successfully fuzz Boa.\\n\\n[arbitrary]: https://docs.rs/arbitrary/latest/arbitrary/\\n\\n### New Crates\\n\\nThis release of Boa will also mark the release of some new boa crates that contain various aspects of Boa\'s ECMAScript\\nimplementation.\\n\\n#### boa_parser\\n\\nBoa\'s `boa_parser` crate contains a lexer and parser that targets the latest ECMAScript language specification.\\n\\n#### boa_ast\\n\\nBoa\'s `boa_ast` crate contains an ECMAScript abstract syntax tree implementation of Declaration, Statement, and\\nExpression Parse Nodes.\\n\\n#### boa_runtime\\n\\nBoa\'s `boa_runtime` crate contains an example runtime along with basic runtime features and functionality for runtime\\nimplementors. Note: this crate will contain any WEB API feature implementations or APIs that are not designated by the\\nECMAScript specification.\\n\\n### Other internal enhancements\\n\\nThere have also been a various number of other internal enhancements made.\\n\\n#### Split Node into Statement / Declaration / Expression\\n\\nIn the last release, Boa\'s AST used a `Node` enum to represent both the `Statement`, `Declaration` and `Expression`\\nparse nodes. One of the large internal improvements made for this release was to split `Node` into `Statement`,\\n`Declaration`, and `Expression` nodes. This refactor involved not only large changes to the AST but also further changes\\nto the bytecompiler and parser. The split also brings us closer in line with the ECMAScript specification.\\n\\n#### UTF-16 strings\\n\\nWith this release, Boa\'s `JsString`s are now implemented as utf-16 encoded strings. Along with the new `JsString`, there\\nare two provided macros: `js_string!` for creating a new `JsString` from a `&str`, and `utf16!` for creating a utf-16\\narray literal from a `&str`.\\n\\nYou can create a utf-16 array literal from any utf-8 `str`.\\n\\n```rust\\nconst HELLO: &[u16] = utf16!(\\"Hi! :)\\");\\n```\\n\\nYou can create a `JsString` from a string literal with the `js_string` macro.\\n\\n```rust\\nlet hw = js_string!(\\"Hello, world!\\");\\nassert_eq!(&hw, utf16!(\\"Hello, world!\\"));\\n```\\n\\nYou can also pass any number of `&[u16]` string values as arguments to create a new `JsString`.\\n\\n```rust\\nconst NAME: &[u16]  = utf16!(\\"human! \\");\\nlet greeting = js_string!(\\"Hello, \\");\\nlet msg = js_string!(&greeting, &NAME, utf16!(\\"Nice to meet you!\\"));\\n\\nassert_eq!(&msg, utf16!(\\"Hello, human! Nice to meet you!\\"));\\n```\\n\\n## Conclusions\\n\\nIf you reached so far, you probably understand how big this release was, and you can find even more changes in the\\n[full changelog][changelog]. Boa is now becoming a real option for many projects, which shows with the amount of\\nfinancial support we have received these last months. Nevertheless, going forward, we need your help to get to a 1.0\\nversion. Whether you are good with Rust, JavaScript, documentation or development, we have multiple\\n[good first issues][first_issues], and places where we [need help][help_wanted], both in Boa\'s\\n[main repository][boa_engine] and [others][boa_org] around it.\\n\\nOnce again, big thanks to [all the contributors][contributors] of this release!!\\n\\n[help_wanted]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22\\n[boa_engine]: https://github.com/boa-dev/boa\\n[boa_org]: https://github.com/boa-dev\\n[contributors]: https://github.com/boa-dev/boa/graphs/contributors?from=2022-10-24&to=2023-07-05&type=c"},{"id":"/2022/10/24/boa-usage","metadata":{"permalink":"/blog/2022/10/24/boa-usage","source":"@site/blog/2022-10-24-boa-usage.md","title":"Adding a JavaScript interpreter to your Rust project","description":"Introduction","date":"2022-10-24T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":13.13,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Adding a JavaScript interpreter to your Rust project","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.17","permalink":"/blog/2023/07/08/boa-release-17"},"nextItem":{"title":"Boa release v0.16","permalink":"/blog/2022/09/25/boa-release-16"}},"content":"## Introduction\\n\\nWhen we develop tools for our users, we sometimes want to give them some form of control over how\\nthey work. This is common in games, where we can add scripting for our users to be able to create\\nextensions, or even for business tools, where we allow our customer to change or extend the\\nbehaviour of our platform. For those cases, using Rust, a compiled, type safe language can be a\\nchallenge, since once a program has been compiled, it\'s tricky to change or extend it at runtime.\\nFurthermore, many of our users will prefer to use a more common scripting language, such as\\nJavaScript.\\n\\nThis is where Boa enters the scene. Boa is a Javascript engine fully written in Rust. Currently, it\\ncan be used in places where you need most of the JavaScript language to work, even though, we would\\nadvise to wait to get all our [known blocker bugs][blocking] solved before using this for critical\\nworkloads. You can check how conformant we are with the official ECMAScript specification\\n[here](https://boa-dev.github.io/boa/test262/).\\n\\nAnd, before going further, we would like to mention that you can contribute to Boa by solving one\\nof the [issues][issues] where we need special help, and we now also accept financial contributions\\nin [our OpenCollective][opencollective] page.\\n\\n_Note: You can see more examples of integrating Boa in [our repository][examples-repo]._\\n\\n[blocking]: https://github.com/boa-dev/boa/issues?q=64+162+718+773+2068+1930+1922+1917+1900+1848+1805+1570+1402+1307+1180+is%3Aopen\\n[issues]: https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22%2CHacktoberfest%2CE-Easy%2C%22good+first+issue%22+no%3Aassignee\\n[opencollective]: https://opencollective.com/boa\\n[examples-repo]: https://github.com/boa-dev/boa/tree/main/boa_examples\\n\\n<!--truncate-->\\n\\n## Starting from scratch\\n\\nLet\'s start a new project running `cargo new my_project`, and then add [`boa_engine`][crate] as one\\nof our dependencies by running `cargo add boa_engine -F console` in our newly created `my_project`\\ndirectory.\\n\\nLet\'s start by adding the minimal code needed to get a JavaScript interpreter working in our\\n`src/main.rs` file:\\n\\n```rust\\nuse boa_engine::Context;\\n\\nfn main() {\\n    let js_code = \\"console.log(\'Hello World from a JS code string!\')\\";\\n\\n    // Instantiate the execution context\\n    let mut context = Context::default();\\n\\n    // Parse the source code\\n    match context.eval(js_code) {\\n        Ok(res) => {\\n            println!(\\"{}\\", res.to_string(&mut context).unwrap());\\n        }\\n        Err(e) => {\\n            // Pretty print the error\\n            eprintln!(\\"Uncaught {}\\", e.display());\\n        }\\n    };\\n}\\n```\\n\\nAs you can see in this example, when working with Boa, you will have to use a [`Context`][context],\\nwhich will be in charge of initializing all the internals and built-in objects (such as `Date`,\\n`Promise` and so on). The `Context` in Boa is also your go-to place for configuring your interpreter\\nas you wish. You can add custom global functions, objects, and anything you might imagine. It\'s also\\none of the arguments you will receive if you create a Rust function and expose it to JavaScript, and\\nwith it, you will be able to throw errors, modify the global object and return values to JavaScript.\\n\\nTalking about values, Boa comes with its built-in [`JsValue`][jsvalue] type. This enumeration\\nrepresents any JavaScript value that can, for example, be assigned to a variable. And, before you\\nask, you can convert it to and from a [`serde_json::Value`][json-value], of course, by using the\\n[`JsValue::from_json()`][from-json] and [`JsValue::to_json()`][to-json] methods.\\n\\nAs you can see in those methods, or in the `Context::eval()` that we used earlier, you will\\nreceive a `JsResult` as a response. This result type will contain a `JsValue` as its error variant,\\nwhich means you can return the error back to JavaScript for it to handle it. A `JsValue`, internally,\\nis a garbage-collected JavaScript value. But, isn\'t Rust one of the few non-garbage collected\\nlanguages? Wasn\'t that a good thing?\\n\\nThe answer is _yes, of course_, but JavaScript requires a garbage collector. This garbage collector\\nmakes sure that all values are freed when they are no longer needed. It also makes a `JsValue`\\nextremely cheap to clone, independently of its contents.\\n\\nIf you run this example code with `cargo run`, you will notice that it will print the message sent\\nto `console.log()`, and it will also print `undefined` at the end. This last `undefined` is part of\\nthe `Ok(res)` branch in the `match`, which prints the result of the execution. In this case, the\\nresult of the execution is the result of the last statement, which is the `console.log()`, and this\\nstatement returns `undefined`.\\n\\n[crate]: https://crates.io/crates/boa_engine\\n[context]: https://docs.rs/boa_engine/latest/boa_engine/struct.Context.html\\n[jsvalue]: https://docs.rs/boa_engine/latest/boa_engine/enum.JsValue.html\\n[json-value]: https://docs.rs/serde_json/latest/serde_json/value/enum.Value.html\\n[from-json]: https://docs.rs/boa_engine/latest/boa_engine/enum.JsValue.html#method.from_json\\n[to-json]: https://docs.rs/boa_engine/latest/boa_engine/enum.JsValue.html#method.to_json\\n\\n## But, what can you do with Boa?\\n\\nLet\'s start with the basics. Of course, you can execute JavaScript code. This code can be any\\nstring or directly a byte vector (so you can load files and use them directly). You can use\\n[`Context::eval()`][context-eval] in both cases, as you saw before, and you can also use\\n[`Context::parse()`][context-parse], which will give you a [`StatementList`][statementlist] that\\nyou can use multiple times in [`Context::compile()`][context-compile], so that you don\'t need to\\nparse the same code more than once. The compiled source code can also be executed multiple times,\\nsince it\'s [`CodeBlock`][codeblock] is garbage collected, and therefore it can be cheaply cloned.\\nIn order to execute a code block you will need to use [`Context::execute()`][context-execute].\\n\\nThis in itself is good enough to provide a simple scripting API for your project, but where Boa\\nreally shines is in the ability to inter-operate Rust and JavaScript. Let\'s start with a simple\\nexample: exposing a Rust function to JavaScript. A JavaScript-compatible Rust function must have\\nthe [`NativeFunctionSignature`][native-function] signature:\\n\\n```rust\\nuse boa_engine::{builtins::JsArgs, Context, JsResult, JsValue};\\n\\n/// Says \\"hello\\" using the first argument.\\nfn say_hello(_this: &JsValue, args: &[JsValue], context: &mut Context) -> JsResult<JsValue> {\\n    let name = args.get_or_undefined(0);\\n\\n    if name.is_undefined() {\\n        println!(\\"Hello World!\\");\\n    } else {\\n        println!(\\"Hello {}!\\", name.to_string(context)?);\\n    }\\n\\n    Ok(JsValue::undefined())\\n}\\n```\\n\\nThe [`JsArgs`][jsargs] trait allows you to retrieve a value if the function received it, or set it\\nto the `undefined` value, if not. Then, in this case, it will convert the name to a `JsString`\\nbefore printing it, since we might be receiving an object, a symbol, a boolean... one of the perks\\nof dynamic typing. This will then print the result in th standard output using the common\\n`println!()` macro in Rust. It will just return an undefined value.\\n\\nYou can register this function in the context by adding this line after the context creation (and\\nbefore executing any JS) in the `main()` function:\\n\\n```rust\\ncontext.register_global_builtin_function(\\"say_hello\\", 1, say_hello);\\n```\\n\\nThis will register it as a global function, with the `say_hello()` name, and with a `length` of 1\\n(which indicates the number of arguments that it receives by default). You can then try it out by\\nmodifying the JavaScript string:\\n\\n```rust\\nlet js_code = r#\\"say_hello(\\"Rust\\");\\"#;\\n```\\n\\nThe `r#\\"...\\"#` syntax is a Rust raw [string literal][rust-string].\\n\\nYou can also add any `JsValue` as a property to the global object by using the\\n[`Context::register_global_property()`][context-property] function:\\n\\n```rust\\nuse boa_engine::property::Attribute;\\n\\ncontext.register_global_property(\\"MY_PROJECT_VERSION\\", \\"1.0.0\\", Attribute::all());\\n```\\n\\nAnd you can use it in JavaScript:\\n\\n```javascript\\nsay_hello(MY_PROJECT_VERSION);\\n```\\n\\nThe [`Attribute`][attribute] of a property indicates if it will be writable (it can be set and\\nmodified), enumerable (it can be used in `for..in` statements) and configurable (its attributes or\\ntype of property can be modified).\\n\\n[context-eval]: https://docs.rs/boa_engine/latest/boa_engine/struct.Context.html#method.eval\\n[context-parse]: https://docs.rs/boa_engine/latest/boa_engine/struct.Context.html#method.parse\\n[statementlist]: https://docs.rs/boa_engine/latest/boa_engine/syntax/ast/node/statement_list/struct.StatementList.html\\n[context-compile]: https://docs.rs/boa_engine/latest/boa_engine/struct.Context.html#method.compile\\n[codeblock]: https://docs.rs/boa_engine/latest/boa_engine/vm/struct.CodeBlock.html\\n[context-execute]: https://docs.rs/boa_engine/latest/boa_engine/struct.Context.html#method.execute\\n[native-function]: https://docs.rs/boa_engine/latest/boa_engine/builtins/function/type.NativeFunctionSignature.html\\n[jsargs]: https://docs.rs/boa_engine/latest/boa_engine/builtins/trait.JsArgs.html\\n[rust-string]: https://doc.rust-lang.org/rust-by-example/std/str.html#literals-and-escapes\\n[context-property]: https://docs.rs/boa_engine/latest/boa_engine/struct.Context.html#method.register_global_property\\n[attribute]: https://docs.rs/boa_engine/latest/boa_engine/property/struct.Attribute.html\\n\\n## Integrating a full Rust data structure\\n\\nSometimes, adding a function or a single `JsValue` to the global scope of your JavaScript context\\nis not enough, and you want to enable the full power of Rust with its structures to handle more\\ncomplex scenarios. This can be achieved using the [`Class`][class] trait. This has to be combined\\nwith two other traits, that make any Rust object be garbage-collected: [`Trace`][trace] and\\n[`Finalize`][finalize], in the [`boa_gc`][boa-gc] crate. Luckily those two traits can be derived.\\n\\nLet\'s start by implementing a `Person` type, that will showcase the potential of this API. Let\'s\\nrun `cargo add gc boa_gc` and add some code:\\n\\n```rust\\nuse boa_gc::{Finalize, Trace};\\n\\n#[derive(Debug, Trace, Finalize)]\\nstruct Person {\\n    /// The name of the person.\\n    name: String,\\n    /// The age of the person.\\n    age: u8,\\n}\\n```\\n\\nThen, we will move the `say_hello()` function to be a static method of `Person`:\\n\\n```rust\\nimpl Person {\\n    /// Says \\"hello\\" using the name and the age of a `Person`.\\n    fn say_hello(this: &JsValue, _args: &[JsValue], context: &mut Context) -> JsResult<JsValue> {\\n        let this = this\\n            .as_object()\\n            .and_then(|obj| obj.downcast_ref::<Self>())\\n            .ok_or_else(|| context.construct_type_error(\\"`this` is not a `Person` object\\"))?;\\n\\n        println!(\\"Hello {}-year-old {}!\\", this.age, this.name);\\n\\n        Ok(JsValue::undefined())\\n    }\\n}\\n```\\n\\nAs you can see, this now uses the `this` parameter of the `say_hello()` function, which should be a\\n`Person`, but in JavaScript you can assign methods of some objects to others, so we must make sure\\nthat on this invocation, we are indeed working with a `Person`, and return a `TypeError` if not.\\n\\nNow, let\'s implement the [`Class`][class] trait. This trait requires a `NAME` constant, which will\\nbe the name of the global object property, and a `LENGTH` for the constructor (the number of\\narguments, by default `0`). Then, it needs a `constructor()` function, which is a native function\\nthat will be called when we do a `new Person()`, and an `init()` function, which will be called by\\nthe `Context` when registering the function in the global scope. It will receive a\\n[`ClassBuilder`][class-builder], which allows you to add a method (both, static and `prototype`), a\\n`property`, also for both cases, accessor properties (to use `get` and `set`) and property\\ndescriptors. You can also get a reference to the `Context` with the `ClasBuilder::context()` method,\\nin case you want to do anything fancier.\\n\\nIn this case, the constructor will take care of constructing the Rust `Person` data structure with\\nthe two arguments it receives, and then register the `say_hello()` method:\\n\\n```rust\\nuse boa_engine::{\\n    builtins::JsArgs,\\n    class::{Class, ClassBuilder},\\n};\\n\\nimpl Class for Person {\\n    const NAME: &\'static str = \\"Person\\";\\n    const LENGTH: usize = 2;\\n\\n    // This is what is called when we construct a `Person` with the expression `new Person()`.\\n    fn constructor(_this: &JsValue, args: &[JsValue], context: &mut Context) -> JsResult<Self> {\\n        let name = args.get_or_undefined(0).to_string(context)?;\\n        let age = args.get_or_undefined(1).to_u32(context)?;\\n\\n        if !(0..=150).contains(&age) {\\n            context.throw_range_error(format!(\\"invalid age `{age}`. Must be between 0 and 150\\"))?;\\n        }\\n\\n        let age = u8::try_from(age).expect(\\"we already checked that it was in range\\");\\n\\n        let person = Person {\\n            name: name.to_string(),\\n            age,\\n        };\\n\\n        Ok(person)\\n    }\\n\\n    /// Here is where the class is initialized, to be inserted into the global object.\\n    fn init(class: &mut ClassBuilder) -> JsResult<()> {\\n        class.method(\\"say_hello\\", 0, Self::say_hello);\\n\\n        Ok(())\\n    }\\n}\\n```\\n\\nIn order to register the class, you will need to use the\\n[`Context::register_global_class()`][context-class] method:\\n\\n```rust\\ncontext\\n    .register_global_class::<Person>()\\n    .expect(\\"could not register class\\");\\n```\\n\\nYou can now adapt the JavaScript code:\\n\\n```javascript\\nlet person = new Person(\\"John\\", 28);\\nperson.say_hello();\\n```\\n\\nIf you want to access the global object from Rust, you can use `Context::global_object()`, which\\nwill return a [`JsObject`][jsobject]. In this object, you can use the\\n[`JsObject::get()`][jsobject-get] function to retrieve any property of the global object, such as\\nthe `MY_PROJECT_VERSION` that you defined earlier, or any intrinsic, such as the `Date` object.\\n\\nWe are now in the process of creating Rust wrappers for all JavaScript intrinsics ([#2098][2098]).\\nFor example, you can create a `JsArray` from a `JsObject` to make it much easier to manipulate a\\nJavaScript array from Rust. In the following example, you\'ll create a new `reverseAppend()` global\\nfunction that will receive an array, reverse it, and then append the _\\"My Project\\"_ string to it.\\nIt will then get the `MY_PROJECT_VERSION` from the global object, and append it to the array.\\n\\n```rust\\nuse boa_engine::{\\n    builtins::JsArgs, object::JsArray, property::Attribute, Context, JsResult, JsValue,\\n};\\n\\n/// Reverses an array and appends the `\\"My Project\\"` string and the `MY_PROJECT_VERSION` global\\n/// property to it.\\nfn reverse_append(_this: &JsValue, args: &[JsValue], context: &mut Context) -> JsResult<JsValue> {\\n    let arr = args\\n        .get_or_undefined(0)\\n        .as_object()\\n        .ok_or_else(|| context.construct_type_error(\\"argument must be an array\\"))?;\\n\\n    let arr = JsArray::from_object(arr.clone(), context)?;\\n\\n    let reverse = arr.reverse(context)?;\\n    reverse.push(\\"My Project\\", context)?;\\n\\n    let global_object = context.global_object().clone();\\n    let version = global_object\\n        .get(\\"MY_PROJECT_VERSION\\", context)\\n        .unwrap_or_default();\\n\\n    reverse.push(version, context)?;\\n\\n    Ok((*reverse).clone().into())\\n}\\n\\nfn main() {\\n    let js_code = r#\\"\\n        let arr = [\'a\', 2, 5.4, \\"Hello\\"];\\n        reverseAppend(arr);\\n    \\"#;\\n\\n    // Instantiate the execution context\\n    let mut context = Context::default();\\n\\n    context.register_global_property(\\"MY_PROJECT_VERSION\\", \\"1.0.0\\", Attribute::all());\\n\\n    context.register_global_builtin_function(\\"reverseAppend\\", 1, reverse_append);\\n\\n    // Parse the source code\\n    match context.eval(js_code) {\\n        Ok(res) => {\\n            println!(\\"{}\\", res.to_string(&mut context).unwrap());\\n        }\\n        Err(e) => {\\n            // Pretty print the error\\n            eprintln!(\\"Uncaught {}\\", e.display());\\n        }\\n    };\\n}\\n```\\n\\nWe are looking for contributors to implement the rest of the wrappers, and of course, we offer mentoring!\\n\\n[class]: https://docs.rs/boa_engine/latest/boa_engine/class/trait.Class.html\\n[trace]: https://docs.rs/boa_gc/latest/boa_gc/trait.Trace.html\\n[finalize]: https://docs.rs/boa_gc/0.16.0/boa_gc/trait.Finalize.html\\n[boa-gc]: https://crates.io/crates/boa_gc\\n[class-builder]: https://docs.rs/boa_engine/latest/boa_engine/class/struct.ClassBuilder.html\\n[context-class]: https://docs.rs/boa_engine/latest/boa_engine/struct.Context.html#method.register_global_class\\n[jsobject]: https://docs.rs/boa_engine/latest/boa_engine/object/struct.JsObject.html\\n[jsobject-get]: https://docs.rs/boa_engine/latest/boa_engine/object/struct.JsObject.html#method.get\\n[2098]: https://github.com/boa-dev/boa/issues/2098\\n\\n## What\'s coming next?\\n\\nBoa\'s development is ongoing non-stop. The next version, v0.17, is already looking pretty nice,\\nwith some great enhancements. For example, [@jedel1043][jedel1043] has created new\\n[\\"lazy\\" errors][lazy-errors], that are much easier to create and throw, since they don\'t need a\\n`Context`, and also enhance the performance. [@nekevss][nekevss] has implemented a\\n[new wrapper][jsregexp] for `RegExp`, and [@anuvratsingh][anuvratsingh] is working on a `Date`\\n[wrapper][jsdate]. [@razican][razican] is working on a JavaScript to Rust\\n[conversion trait][jsrust] and derive, that will allow you to convert a `JsValue` to a Rust\\nstructure and back really easily:\\n\\n```rust\\nuse boa_derive::TryFromJs;\\nuse boa_engine::{value::TryFromJs, Context, JsResult, JsValue};\\n\\n#[derive(Debug, TryFromJs)]\\n#[allow(dead_code)]\\nstruct TestStruct {\\n    inner: bool,\\n    hello: String,\\n    #[boa(from_js_with = \\"lossy_conversion\\", hello = \\"myfriend\\")]\\n    my_float: i16,\\n}\\n\\nfn main() {\\n    let js = r#\\"\\n    let x = {\\n        inner: false,\\n        hello: \\"World\\",\\n        my_float: 2.9,\\n    };\\n\\n    x;\\n    \\"#;\\n\\n    let mut context = Context::default();\\n    let res = context.eval(js).unwrap();\\n\\n    let str = TestStruct::try_from_js(&res, &mut context)\\n        .map_err(|e| e.display().to_string())\\n        .unwrap();\\n\\n    println!(\\"{str:?}\\");\\n}\\n\\n/// Converts the value lossly\\nfn lossy_conversion(value: &JsValue, context: &mut Context) -> JsResult<i16> {\\n    match value {\\n        JsValue::Rational(r) => Ok(r.round() as i16),\\n        JsValue::Integer(i) => Ok(*i as i16),\\n        _ => context.throw_type_error(\\"cannot convert value to an i16\\"),\\n    }\\n}\\n```\\n\\nWe love contributions, whether it\'s a documentation enhancement, fixing or implementing the\\nECMAScript specification, adding new functionality / APIs or enhancing performance, we would love\\nto get new contributors on board! We are also looking for financial contributors, so feel free to\\njoin our [OpenCollective][opencollective].\\n\\n[jedel1043]: https://github.com/jedel1043\\n[nekevss]: https://github.com/nekevss\\n[lazy-errors]: https://github.com/boa-dev/boa/pull/2283\\n[jsregexp]: https://github.com/boa-dev/boa/pull/2326\\n[anuvratsingh]: https://github.com/anuvratsingh\\n[jsdate]: https://github.com/boa-dev/boa/pull/2181\\n[razican]: https://github.com/Razican\\n[jsrust]: https://github.com/boa-dev/boa/pull/2276"},{"id":"/2022/09/25/boa-release-16","metadata":{"permalink":"/blog/2022/09/25/boa-release-16","source":"@site/blog/2022-09-25-boa-release-16.md","title":"Boa release v0.16","description":"Summary","date":"2022-09-25T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":4.13,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.16","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Adding a JavaScript interpreter to your Rust project","permalink":"/blog/2022/10/24/boa-usage"},"nextItem":{"title":"Boa release v0.15","permalink":"/blog/2022/06/10/boa-release-15"}},"content":"## Summary\\n\\nBoa v0.16 is now available! After around 3 months of development, we are very happy to present you the newest release of\\nthe Boa JavaScript engine. Boa makes it easy to embed a JS engine in your projects, and you can even use it from\\nWebAssembly. See the [about](/about) page for more info.\\n\\nBoa currently supports part of the JavaScript language. In this release, our conformance has grown from 62.29% to 74.53%\\nin the official ECMAScript Test Suite (Test262). The engine now passes 68,612 tests, coming from 56,372 in Boa 0.15\\n(21.7% increase), and we have closed 9 issues and merged 59 pull requests. You can check the full list of changes\\n[here](https://github.com/boa-dev/boa/blob/v0.16/CHANGELOG.md), and the full information on conformance\\n[here](https://boa-dev.github.io/boa/test262/).\\n\\n<!--truncate-->\\n\\n## New ECMAScript features\\n\\n### Support for Promises\\n\\nWith this new release Boa ships support for ECMAScript Promises. All tests in the 262 test suite `built-ins/Promise` pass.\\nPromises enable asynchronous operations to be executed via an internal job queue. Starting with our work on Promises,\\nwe have stopped ignoring the 262 tests that are flagged as `async`. We also have enabled our 262 test runner to work\\nwith asynchronous tests. We would like to thank [@aaronmunsters](https://github.com/aaronmunsters) for proposing\\nthe initial PR for Promises ([#1923](https://github.com/boa-dev/boa/pull/1923)) that we then could expand on.\\n\\n```javascript\\n// This program will print:\\n//    1. End of synchronous execution.\\n//    2. The Promise has been resolved.\\n\\nlet promise = Promise.resolve();\\n\\npromise.then(() => console.log(\\"2. The Promise has been resolved.\\"));\\n\\nconsole.log(\\"1. End of synchronous execution.\\");\\n```\\n\\n### Support for Async/Await\\n\\nThe implementation of Promises has enabled us to implement async functions and the await keyword. The async/await syntax\\nmakes it easier to use Promises within javascript. We have implemented async functions, async generators,\\n`for await...of` loops and the `await` keyword. While not all tests pass for these features yet, the basic functionality\\nshould work.\\n\\n## Dense/Packed JavaScript Arrays\\n\\nJavaScript Arrays are regular objects whose values are stored as indexed properties. Because arrays have no fixed\\nlength, values can be assigned to any possible index without any of the previous indices being used. Due to this\\nbehavior indexed properties are stored in a map instead of in a vector, as the vector would allocate a lot of unused\\nmemory if a high index is used. We have implemented an optimization to make it possible to use optimized vector storage\\nfor array values, as long as indices are not assigned out of order. This has improved the performance of arrays around\\n**45%** for arrays without empty slots. To learn more about this optimization take a look at the PR\\n[#2167](https://github.com/boa-dev/boa/pull/2167).\\n\\n## Support for URI encoding and decoding functions\\n\\nThis version for Boa ships with support for the built-in URI encoding and decoding functions `encodeURI`, `decodeURI`,\\n`encodeURIComponent` and `decodeURIComponent`. With the exception of UTF-16 related test, all test in the relevant 262\\ntest suites pass for these functions.\\n\\n## How can you contribute to Boa?\\n\\nIn March, Boa opened financial contributions on its [OpenCollective page](https://opencollective.com/boa).\\nIf financial contribution is not your strength, you can contribute by asking to be assigned to one of our\\n[open issues](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+no%3Aassignee), and asking for mentoring if you\\ndon\'t know your way around the engine. Our [contribution guide](https://github.com/boa-dev/boa/blob/main/CONTRIBUTING.md)\\nshould help you here. If you are more used to working with JavaScript or frontend web development, we also\\nwelcome help to improve our web presence, either in [our website](https://github.com/boa-dev/boa-dev.github.io), or in\\nour [testing representation](https://github.com/boa-dev/boa/issues/820) page or benchmarks page. You can also contribute to\\nour Criterion benchmark comparison GitHub [action](https://github.com/boa-dev/criterion-compare-action).\\n\\nWe are also looking to improve the documentation of the engine, both for developers of the engine itself and for users of the\\nengine. Feel free to contact us in [Discord](https://discord.gg/tUFFk9Y).\\n\\n### Thank You\\n\\nLast but certainly not least, a big **Thank You** to\\n[all the contributors](https://github.com/boa-dev/boa/graphs/contributors?from=2022-06-11&to=2022-09-25&type=c)\\nof this Boa release. We would like to particularly thank our new contributors:\\n\\n- [@CYBAI](https://github.com/CYBAI) who made their first contribution in [#2108](https://github.com/boa-dev/boa/pull/2108)\\n- [@udhaykumarbala](https://github.com/udhaykumarbala) who made their first contribution in [#2245](https://github.com/boa-dev/boa/pull/2245)\\n- [@tunz](https://github.com/tunz) who made their first contribution in [#2261](https://github.com/boa-dev/boa/pull/2261)\\n- [@anuvratsingh](https://github.com/anuvratsingh) who made their first contribution in [#2162](https://github.com/boa-dev/boa/pull/2162)\\n- [@creampnx-x](https://github.com/creampnx-x) who made their first contribution in [#2274](https://github.com/boa-dev/boa/pull/2274)"},{"id":"/2022/06/10/boa-release-15","metadata":{"permalink":"/blog/2022/06/10/boa-release-15","source":"@site/blog/2022-06-10-boa-release-15.md","title":"Boa release v0.15","description":"Summary","date":"2022-06-10T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":5.21,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.15","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.16","permalink":"/blog/2022/09/25/boa-release-16"},"nextItem":{"title":"Boa release v0.14","permalink":"/blog/2022/03/15/boa-release-14"}},"content":"## Summary\\n\\nBoa v0.15 is now available! After around 3 months of development, we are very happy to present you the newest release of the\\nBoa JavaScript engine. Boa makes it easy to embed a JS engine in your projects, and you can even use it from WebAssembly. See\\nthe [about](/about) page for more info.\\n\\nBoa currently supports part of the JavaScript language. In this release, our conformance has grown from 49.74% to 62.29%\\nin the official ECMAScript Test Suite (Test262). The engine now passes 56,372 tests, coming from 43,986 in Boa 0.14\\n(28.1% increase), and we have closed 18 issues and merged 58 pull requests. You can check the full list of changes\\n[here](https://github.com/boa-dev/boa/blob/v0.15/CHANGELOG.md), and the full information on conformance\\n[here](https://boa-dev.github.io/boa/test262/).\\n\\n<!--truncate-->\\n\\n## New ECMAScript features\\n\\nWhile there are only a few big new features in this release, there are a lot of fixes for existing features that should enable\\nmany more JavaScript programs to execute correctly. For a detailed list checkout the\\n[changelog](https://github.com/boa-dev/boa/blob/v0.15/CHANGELOG.md).\\n\\n### Support for Classes\\n\\nWith this new release boa ships with support for ECMAScript Classes. While not all features are implemented, most basic\\nfunctionality should work as expected.\\n\\n```javascript\\nclass Rectangle {\\n  constructor(height, width) {\\n    this.height = height;\\n    this.width = width;\\n  }\\n\\n  calcArea() {\\n    return this.height * this.width;\\n  }\\n\\n  get area() {\\n    return this.calcArea();\\n  }\\n}\\n\\nlet r = new Rectangle(2, 4);\\nr.calcArea(); // 8\\n```\\n\\n### Support for `eval()` and `Function()`\\n\\nWhile `eval()` is one of the less popular Javascript features, many tests in the ECMAScript Test Suite use it. For a\\nbetter representation of passing tests and to fully comply with the specification we have implemented it and the similar\\n`Function()` constructor. We would like to echo the mdn docs and point out to\\n[Never use eval()!](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!)\\n\\n```javascript\\neval(\'console.log(\\"Never use eval()!\\")\');\\n\\nlet f = Function(\\"arg\\", \'console.log(\\"This is also a very \\" + arg + \\" idea!\\")\');\\nf(\\"bad\\");\\n```\\n\\nThanks to [@raskad](https://github.com/raskad) for working on classes, `eval()` and `Function()`, among many other things!\\n\\n## Regaining Performance\\n\\nAfter moving from an AST based execution to our Virtual Machine we observed performance losses in some of our benchmarks. We\\nfound out that the root-cause of these losses was a single `format!()` call in the hot-path of the VM. Our assumption was that\\nthe formatting logic would be optimized out by rustc or llvm, because it was used as an argument to an empty (feature-gated)\\nfunction. After replacing the `format!()` call with a `&\'static str` the expected optimization took place and we were back to\\nprevious performance levels. For more details check out [#1973](https://github.com/boa-dev/boa/pull/1973) for the changes and\\nsome discussion about this issue. Thanks to [@pdogr](https://github.com/pdogr) for finding the issue and contributing a fix.\\n\\n## Starting work on Internationalization\\n\\nECMAScript specifies an Internationalization API through the `Intl` global object. We have started implementing many internal\\nfunctions and structures to provide the `Intl` object in boa. To take advantage of existing work in this space we have started\\nintegrating the [ICU4X library](https://github.com/unicode-org/icu4x) into boa. Thanks to\\n[@NorbertGarfield](https://github.com/NorbertGarfield) and [@jedel1043](https://github.com/jedel1043) for their continued work\\non this topic.\\n\\n## Rust Wrappers for Javascript Objects\\n\\nWe have started the implementation of wrappers around built-in Javascript objects like `Array`. These Rust types make it easy\\nto work with Javascript objects in Rust and provide a type safe abstraction around them. Many of these wrappers are not\\nimplemented yet and may be a good place to start contributing to boa. If you are interested, check out the\\n[tracking issue](https://github.com/boa-dev/boa/issues/2098).\\n\\n## How can you contribute to Boa?\\n\\nIn March, boa opened financial contributions on its [OpenCollective page](https://opencollective.com/boa). Since then, we have\\nto thank Demergent Labs, a company using Boa in the Internet Computer that has decided to sponsor us, and Clemens\\nKoza, who is our first backer! We are already thinking on how we will use these contributions to improve how we develop Boa.\\n\\nIf financial contribution is not your strength, you can contribute by asking to be assigned to one of our\\n[open issues](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+no%3Aassignee), and asking for mentoring if you\\ndon\'t know your way around the engine. Our [contribution guide](https://github.com/boa-dev/boa/blob/main/CONTRIBUTING.md)\\nshould help you here. If you are more used to working with JavaScript or frontend web development, we also\\nwelcome help to improve our web presence, either in [our website](https://github.com/boa-dev/boa-dev.github.io), or in\\nour [testing representation](https://github.com/boa-dev/boa/issues/820) page or benchmarks page. You can also contribute to\\nour Criterion benchmark comparison GitHub [action](https://github.com/boa-dev/criterion-compare-action).\\n\\nWe are also looking to improve the documentation of the engine, both for developers of the engine itself and for users of the\\nengine. Feel free to contact us in [Discord](https://discord.gg/tUFFk9Y).\\n\\n### Thank You\\n\\nLast but certainly not least, a big **Thank You** to\\n[all the contributors](https://github.com/boa-dev/boa/graphs/contributors?from=2022-03-16&to=2022-06-10&type=c) of this Boa\\nrelease. We would like to particularly thank our new contributors:\\n\\n- [@lupd](https://github.com/lupd) who made their first contribution in [#1979](https://github.com/boa-dev/boa/pull/1979)\\n- [@NorbertGarfield](https://github.com/NorbertGarfield) who made their first contribution in [#1963](https://github.com/boa-dev/boa/pull/1963)\\n- [@pdogr](https://github.com/pdogr) who made their first contribution in [#1968](https://github.com/boa-dev/boa/pull/1968)\\n- [@kilotaras](https://github.com/kilotaras) who made their first contribution in [#1959](https://github.com/boa-dev/boa/pull/1959)\\n- [@tsutton](https://github.com/tsutton) who made their first contribution in [#1999](https://github.com/boa-dev/boa/pull/1999)\\n- [@manthanabc](https://github.com/manthanabc) who made their first contribution in [#1957](https://github.com/boa-dev/boa/pull/1957)\\n- [@lastmjs](https://github.com/lastmjs) who made their first contribution in [#1990](https://github.com/boa-dev/boa/pull/1990)\\n- [@YXL76](https://github.com/YXL76) who made their first contribution in [#2042](https://github.com/boa-dev/boa/pull/2042)"},{"id":"/2022/03/15/boa-release-14","metadata":{"permalink":"/blog/2022/03/15/boa-release-14","source":"@site/blog/2022-03-15-boa-release-14.md","title":"Boa release v0.14","description":"Summary","date":"2022-03-15T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":6.46,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.14","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.15","permalink":"/blog/2022/06/10/boa-release-15"},"nextItem":{"title":"Boa release v0.13","permalink":"/blog/2021/09/30/boa-release-13"}},"content":"## Summary\\n\\nBoa v0.14 is here! After almost 6 months of development, we are very happy to present you the newest release of the Boa\\nJavaScript engine. Boa makes it easy to embed a JS engine in your projects, and you can even use it from webassembly. See\\nthe [about](/about) page for more info. Together with this release, we present you: A new way to contribute to Boa, a virtual machine, usable examples and much more.\\n\\nBoa currently supports part of the JavaScript language. In this release, our conformance has grown from 41.01% to 49.74%\\nin the official ECMAScript Test Suite (Test262). The engine now passes 43,986 tests, coming from 33,192 in Boa 0.13\\n(32.5% increase), and we have closed 40 issues and merged 137 pull requests. You can check the full list of changes\\n[here](https://github.com/boa-dev/boa/blob/v0.14/CHANGELOG.md), and the full information on conformance\\n[here](https://boa-dev.github.io/boa/test262/).\\n\\n<!--truncate-->\\n\\n## Boa has moved\\n\\nFirst off, some breaking changes!\\nBoa is now [`boa_engine`](https://crates.io/crates/boa_engine) on crates.io. This should bring it in line with our other packages, and allows us to resolve the [casing issue](https://github.com/boa-dev/boa/issues/230) we had with Boa previously. It should just be a case of changing your dependencies in cargo.toml to the new destination. The old [`Boa`](https://crates.io/crates/boa) crate will no longer receive any updates.\\n\\n## New ECMAScript features\\n\\nBoa v0.14 ships with support for `Object.getOwnPropertyNames`, `Object.getOwnPropertySymbols`, `Object.prototype.hasOwnProperty`, `Array.from`, `AggregateError`, `Typed Arrays`, `Proxy`, `toLocaleString()`, `Symbol.prototype.valueOf`, `Array.prototype.at()`, `String.fromCharCode`, `Object.hasOwn`, `Object.fromEntries`, `Proxy`, `Array.prototype.findLast`, `Array.prototype.findLastIndex`, `console.trace`, `String.raw( template, ...substitutions )`, and [more](https://github.com/boa-dev/boa/blob/v0.14/CHANGELOG.md). There\'s also been several bug fixes and internal improvements, such as [switching to Bors](https://github.com/boa-dev/boa/pull/1684) for our CI management.\\n\\n## Virtual Machine\\n\\nThe biggest change in this release has definitely been the switch of the main implementation to a Virtual Machine. The\\nJavaScript code first gets parsed into AST, then compiled into op-codes, and finally executed in the VM. This adds some\\nextra steps, which, for now, have reduced the performance of the engine. We hope to fix some of these degradations over the course of the next few releases so hang tight. The new VM opens the door for many great features in the future (we\'re looking at you, async/await), and allows some nicer optimizations in the parsing and compilation phases in which we have already started working (such as [#1829](https://github.com/boa-dev/boa/pull/1829) and\\n[#1849](https://github.com/boa-dev/boa/pull/1849)).\\n\\nThis move towards a VM has also brought one great new feature, generator execution ([#1790](https://github.com/boa-dev/boa/pull/1790)).\\nYou can find out more about how to use the VM [here](https://github.com/boa-dev/boa/blob/main/docs/vm.md).\\n\\n<img class=\\"light\\" src=\\"/images/2022-03-15/boa_architecture_light.svg\\" />\\n<img class=\\"dark\\" src=\\"/images/2022-03-15/boa_architecture_dark.svg\\" />\\n\\n<br />\\n\\n## Boa opens financial contributions\\n\\nIn the past months, due to the big and steady progress on Boa, we have received multiple requests to contribute to Boa\\nfinancially. From now on, anyone can contribute with either a recurring donation, or a one-time contribution in our\\n[OpenCollective page](https://opencollective.com/boa).\\n\\n### What does this mean for Boa?\\n\\nBeing able to receive financial contributions won\'t directly show a change in Boa development, but depending on how much\\nfunding we get, we are already planning next steps. Having more motivated contributors would be the first step. We all\\nwant to spend more of our free time in boa, and receiving a financial compensation for it is definitely making the team\\nmembers eager to continue contributing.\\n\\nBut that is not our only idea. We would like to create a reproducible benchmarking platform. Currently, we just use GitHub\\nactions for benchmarking, which is useful to get some general ideas on how some changes affect the performance of the\\nengine. However, they have a high variability (up to 10%), meaning that we can definitely see changes if they are big, but it\'s\\nimpossible to see differences if changes are minimal (1-2%, for example). Having the infrastructure to do proper performance\\ntesting would require using dedicated CPUs, for example, which could be financed using the Boa Open Collective.\\n\\nOn the development side, there are some very big projects that require deep involvement from the team. Priorities include (not neccesarily in order):\\n\\n- [Async/Await support](https://github.com/boa-dev/boa/projects/3).\\n- Better [completion records](https://github.com/boa-dev/boa/projects/5) implementation\\n- Performance improvement across the board.\\n- Future implementation of Shapes/Hidden Classes.\\n- Being able to measure against other engines.\\n- Improved conformance of the EcmaScript specification.\\n- Integration with [ICU4X](https://github.com/unicode-org/icu4x) for Intl and future Temporal implementation.\\n\\nImplementing a [proper API](https://github.com/boa-dev/boa/discussions/1531) for Rust crates that want to embed Boa as they\\nlike, or a [C API](https://github.com/boa-dev/boa/issues/332) so that other software, not written in Rust, can use Boa,\\nare also a priority, and implementing all the new built-in objects to achieve 100% conformance with the ECMAScript\\nspecification is also a must. All this takes time, and we will need to finance developers working on these big issues.\\n\\n### Can I contribute differently?\\n\\nIf financial contribution is not your strength, you can contribute by asking to be assigned to one of our\\n[open issues](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+no%3Aassignee), and asking for mentoring if you\\ndon\'t know your way around the engine. Our [contribution guide](https://github.com/boa-dev/boa/blob/main/CONTRIBUTING.md)\\nshould help you here. If you are more used to working with JavaScript or frontend web development, we also\\nwelcome help to improve our web presence, either in [our website](https://github.com/boa-dev/boa-dev.github.io), or in\\nour [testing representation](https://github.com/boa-dev/boa/issues/820) page or benchmarks page. You can also contribute to\\nour Criterion benchmark comparison GitHub [action](https://github.com/boa-dev/criterion-compare-action).\\n\\nWe are also looking to improve the documentation of the engine, both for developers of the engine itself and for users of the\\nengine. Feel free to contact us in [Discord](https://discord.gg/tUFFk9Y).\\n\\n### Thank You\\n\\nLast but certainly not least, a big **Thank You** to all the contributors of Boa.\\nIt\'s not often we list them but we would like to say thank you to the new contributors who joined for the last release.\\n\\n#### Thank you New Contributors\\n\\n- [@abhishekc-sharma](https://github.com/abhishekc-sharma) who made their first contribution in [#1612](https://github.com/boa-dev/boa/pull/1612)\\n- [@kevinputera](https://github.com/kevinputera) who made their first contribution in [#1606](https://github.com/boa-dev/boa/pull/1606)\\n- [@nrabulinski](https://github.com/nrabulinski) who made their first contribution in [#1614](https://github.com/boa-dev/boa/pull/1614)\\n- [@hle0](https://github.com/hle0) who made their first contribution in [#1618](https://github.com/boa-dev/boa/pull/1618)\\n- [@nekevss](https://github.com/nekevss) who made their first contribution in [#1613](https://github.com/boa-dev/boa/pull/1613)\\n- [@lowr](https://github.com/lowr) who made their first contribution in [#1628](https://github.com/boa-dev/boa/pull/1628)\\n- [@Nimpruda](https://github.com/Nimpruda) who made their first contribution in [#1634](https://github.com/boa-dev/boa/pull/1634)\\n- [@atouchet](https://github.com/atouchet) who made their first contribution in [#1638](https://github.com/boa-dev/boa/pull/1638)\\n- [@praveenbakkal](https://github.com/praveenbakkal) who made their first contribution in [#1680](https://github.com/boa-dev/boa/pull/1680)\\n- [@bsinky](https://github.com/bsinky) who made their first contribution in [#1665](https://github.com/boa-dev/boa/pull/1665)\\n- [@TheDoctor314](https://github.com/TheDoctor314) who made their first contribution in [#1691](https://github.com/boa-dev/boa/pull/1691)"},{"id":"/2021/09/30/boa-release-13","metadata":{"permalink":"/blog/2021/09/30/boa-release-13","source":"@site/blog/2021-09-30-boa-release-13.md","title":"Boa release v0.13","description":"Boa v0.13 is here! Boa is a JavaScript engine written in the Rust programming language. It makes it easy to embed a JS engine in your projects, and you can even use it from webassembly. See the about page for more info.","date":"2021-09-30T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":4.91,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.13","authors":"boa-dev","permalink":"2021/09/30/boa-release-13.html"},"unlisted":false,"prevItem":{"title":"Boa release v0.14","permalink":"/blog/2022/03/15/boa-release-14"},"nextItem":{"title":"Boa release v0.12","permalink":"/blog/2021/06/07/boa-release-12"}},"content":"Boa v0.13 is here! Boa is a JavaScript engine written in the Rust programming language. It makes it easy to embed a JS engine in your projects, and you can even use it from webassembly. See the [about](/about) page for more info.\\n\\nWe currently support part of the language. In this release, our conformance has grown to 41.97% of the official ECMAScript Test Suite (Test262). We have closed 40 issues and merged 105 pull requests. You can check the full list of changes [here](https://github.com/boa-dev/boa/blob/v0.13/CHANGELOG.md).\\n\\nThis release brings some new features, such as support for calling Rust closures from JavaScript to improve better interopability between JS and Rust.\\n\\n<!--truncate-->\\n\\n## ECMAScript language features\\n\\n[named capture groups](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges) are now implemented and enabled.\\n\\n```javascript\\nconst RE_DATE = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\\n\\nconst matchObj = RE_DATE.exec(\\"1999-12-31\\");\\nconst year = matchObj.groups.year; // 1999\\nconst month = matchObj.groups.month; // 12\\nconst day = matchObj.groups.day; // 31\\n```\\n\\nThis release brings support for the relative indexing method [String.prototype.at()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/at). This makes it easier to fetch values at the end of an array or string instead of doing `str[str.length - 1]`.\\n\\n```javascript\\nconst sentence = \\"The quick brown fox jumps over the lazy dog.\\";\\nlet index = 5;\\nconsole.log(\\n  `Using an index of ${index} the character returned is ${sentence.at(index)}`,\\n);\\n// expected output: \\"Using an index of 5 the character returned is u\\"\\n```\\n\\nOther implemented language features include destructoring assignments, `replaceAll()`, `Object.values()`, `Object.keys()`, `Object.preventExtensions()`, `splice()`, `sort()`, spreading objects and more.\\n\\n## Boa API\\n\\n### Calling Rust closures from JavaScript\\n\\nIn addition to registering Rust functions as global JavaScript functions, our API has been expanded to register Rust closures. [`register_global_closure`](https://docs.rs/Boa/0.13.0/boa/context/struct.Context.html#method.register_global_closure) allows to capture variables in closures that can be called from javascript:\\n\\n```rust\\nlet mut context = Context::new();\\nlet add_value = 1.0;\\ncontext.register_global_closure(\\"addOne\\", 1, move |_, args, _| {\\n    let argument = args.get(0).unwrap().as_number().unwrap();\\n    Ok(JsValue::new(argument + add_value))\\n})?;\\nassert_eq!(context.eval(\\"addOne(41)\\")?, 42.into());\\n```\\n\\nTo see the full capabilities of this feature, take a look at our [examples](https://github.com/boa-dev/boa/blob/main/boa/examples/closures.rs). Thanks to @HalidOdat and @jedel1043 for their work on this.\\n\\n### Boa prelude\\n\\nThis release exposes a prelude of useful things that are already imported. This should make it more ergonomic to work with.\\n\\n```rust\\nuse boa::prelude::*; // This would import all the commonly-used things\\n\\nfn main() {\\n\\tlet number = JSValue::number(3.1415);\\n\\tlet realm = Realm::create();\\n\\tlet mut engine = Interpreter::new(realm);\\n\\tlet result = forward(&mut engine, \\"Math.PI\\");\\n}\\n```\\n\\n## Test 262\\n\\nTest262 is the implementation conformance test suite maintained by TC39. It\'s used by nearly all engines to measure how conformant they are to the specification. Boa pulls the tests in-tree and runs them against all PRs.\\n\\nSince v0.12 we have managed to pass 6391 more tests and are 7% more conformant. This has been great progress by all involved and we hope this continues to improve. Most of these new passes have come from refactors across the codebase which have had little impact on performance, in fact, v0.13 is much faster than v0.12.\\n\\nYou can track Boa\'s conformance to the specification [here](https://boa-dev.github.io/boa/test262/#)\\n\\n## Keeping up with Rust\\n\\nRust is changing underneath us. This means we need to make sure our code is conforming the latest standards and we\'re taking advantage of the best optimizations the language can provide. In order to do this we rely on Clippy, this is Rust\'s in-house linter. We updated our code to [respect the latest Rust version](https://github.com/boa-dev/boa/pull/1352) and updated [formatting](https://github.com/boa-dev/boa/pull/1356). Often a nice bonus of doing this is getting performance improvements for free as Clippy gets more \\"smarter\\". Thanks to @neeldug and @RageKnify for the work in this area.\\n\\n## Keeping things in order\\n\\nPreviously object properties were stored using [`FxHashMap`](https://docs.rs/rustc-hash/1.1.0/rustc_hash/type.FxHashMap.html). Despite being very fast it didn\'t offer any guarantees about the order. Properties need to retain the same order they were entered. In order to achieve this we switched over to [IndexMap](https://docs.rs/indexmap/1.7.0/indexmap/). Traits in Rust make this easy as IndexMap was designed to be a drop-in replacement for other HashMap implementations by following the same Trait. Thanks to IndexMap offering the possibility to use alternative hashing algorithms, we could continue using the fast [`FxHasher`](https://docs.rs/rustc-hash/1.1.0/rustc_hash/struct.FxHasher.html) algorithm from rustc. Performance losses were minimal on some benchmarks and we actually made some gains in others. Thanks to @raskad for their work on this\\n\\n## VM\\n\\nThere is still on-going work to utilise a VM, this is happening [alongside](https://github.com/boa-dev/boa/blob/main/docs/vm.md#state-of-play) how Boa runs today. Although its not exposed yet there has been plenty of refactorings to the VM in order to make it performant. Hopefully we can talk about this in more detail soon.\\n\\n## Opening up the discussion\\n\\nAs of this release Boa has begun to utilise Github\'s Discussions feature. You can catch more long-ranging projects [here](https://github.com/boa-dev/boa/discussions)\\n\\n## Thank You\\n\\nThis has been the biggest release yet, there have been many features and fixes. We want to thank all the [contributors](https://github.com/boa-dev/boa/graphs/contributors?from=2021-06-01&to=2021-09-26&type=c) in this release, whether it was features, fixes or raising bugs.\\n\\nIf you\'re interested in contributing to Boa, we have some [\\"good first issues\\"](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) and [\\"issues where help is wanted\\"](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22)."},{"id":"/2021/06/07/boa-release-12","metadata":{"permalink":"/blog/2021/06/07/boa-release-12","source":"@site/blog/2021-06-07-boa-release-12.md","title":"Boa release v0.12","description":"Boa v0.12 is here! Boa is a JavaScript parser, compiler and executor written in the Rust programming language. It makes it easy to embed a JS engine in your projects, and you can even use it from webassembly. See the About page for more info.","date":"2021-06-07T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":2.54,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.12","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.13","permalink":"/blog/2021/09/30/boa-release-13"},"nextItem":{"title":"Boa release v0.11","permalink":"/blog/2021/01/14/boa-release-11"}},"content":"Boa v0.12 is here! Boa is a JavaScript parser, compiler and executor written in the Rust programming language. It makes it easy to embed a JS engine in your projects, and you can even use it from webassembly. See the [About](/about) page for more info.\\n\\nWe currently support part of the language. In this release, our conformance has grown to 33.97% of the official ECMAScript Test Suite (Test262). In this release, we have closed 19 issues and merged 69 pull requests. You can check the full list of changes [here](https://github.com/boa-dev/boa/blob/v0.12/CHANGELOG.md).\\n\\nLet\'s dive into the most relevant changes of this release.\\n\\n<!--truncate-->\\n\\n## Panic-free\\n\\nBoa now doesn\'t panic in any of the Test262 tests. This is a huge milestone, since it means that the engine itself can handle all of the edge cases. At least those proposed by the official ECMAScript test suite. We still recommend using [`std::panic::catch_unwind()`](https://doc.rust-lang.org/stable/std/panic/fn.catch_unwind.html) to execute arbitrary code, though.\\n\\n## Conformance increase\\n\\nIn version 0.11 we were passing 31.59% of the Test262 suite. In this version, we have increased that coverage to **33.97%**. The increase might not seem much, but we now pass 1,924 new tests.\\n\\nOur conformance tester has also been improved, and thanks to the new APIs available in the engine, we were able to add complex functionality such as \\"realm\\" creation, cross-real symbols and overall, the inclusion of a partially complete `$262` object, ready for some testing.\\n\\nWe have also added some useful lists of \\"fixed\\", \\"broken\\", \\"ignored\\" and \\"fixed panics\\" tests for each pull request. This will allow us to directly check individual tests on each PR and only re-run the new tests that are failing/panicking in order to properly fix them.\\n\\n## New built-in objects, `string` improvements and `@@ToStringTag`\\n\\nBoa now has support for the `Reflect` and `Set` built-in objects. This grows the posibilities of the engine to be used in more real-world projects. On the same lines, we have added support for the `GetOwnProperty` for `string`. This means that we can use `[{index}]` to get the characters of a string. For example, `\\"hello\\"[0]` will return `\\"h\\"`.\\n\\nWe have also added the `@@ToStringTag` well known symbol to most of the built-in objects. You can now run the following code, for example, and get the expected result:\\n\\n```javascript\\nlet result = new Map()[Symbol.toStringTag];\\n\\nconsole.log(result); // Returns \\"Map\\"\\n```\\n\\n## Thank you\\n\\nEverything in this release has been such a huge effort, we want to thank all the [contributors](https://github.com/boa-dev/boa/graphs/contributors?from=2021-01-12&to=2021-06-07&type=c) in this release, whether it was features, fixes or raising bugs.\\n\\nIf you\'re interested in contributing to Boa, we have some [\\"good first issues\\"](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) and [\\"issues where help is wanted\\"](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22)."},{"id":"/2021/01/14/boa-release-11","metadata":{"permalink":"/blog/2021/01/14/boa-release-11","source":"@site/blog/2021-01-14-boa-release-11/index.mdx","title":"Boa release v0.11","description":"Boa has reached a new release. v0.11, our biggest one yet!","date":"2021-01-14T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":5.88,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.11","authors":"boa-dev"},"unlisted":false,"prevItem":{"title":"Boa release v0.12","permalink":"/blog/2021/06/07/boa-release-12"},"nextItem":{"title":"Boa release v0.10","permalink":"/blog/2020/10/02/boa-release-10"}},"content":"Boa has reached a new release. v0.11, our biggest one yet!\\n\\nSince v0.10 we\'ve closed 77 issues and merged 129 pull requests. The engine has been faster and more compliant to the spec. Below are some of the highlights but please see the [changelog](https://github.com/boa-dev/boa/blob/main/CHANGELOG.md#0110-2021-01-14) for more information.\\n\\nWhat is Boa? See the [About](/about) page for more info.\\n\\n<!--truncate-->\\n\\n## Test 262\\n\\nTest262 is the implementation conformance test suite maintained by TC39. It\'s used by nearly all engines to measure how conformant they are to the specification. Boa pulls the tests in-tree and runs them against all PRs. You can find more about Test262 [here](https://github.com/tc39/test262).\\n\\nSince v0.10 we have almost doubled on spec conformance, and reduced panics. A year ago Boa didn\'t even track itself against Test262 so it was difficult to know how compliant we were to the spec, today not only do we track all changes against Test262 but we can see progress on a PR to PR basis.\\n\\nimport ThemedImage from \\"@theme/ThemedImage\\";\\nimport conformance_light from \\"./conformance_light.png\\";\\nimport conformance_dark from \\"./conformance_dark.png\\";\\n\\n<ThemedImage\\n  alt=\\"Conformance graph\\"\\n  sources={{\\n    light: conformance_light,\\n    dark: conformance_dark,\\n  }}\\n/>\\n\\nPreviously many tests failed to run as the test-runner was still being worked on. Those issues have been fixed and our tests jumped from 38k to 78K which is why the graph flips up above. Boa should never panic, however we\'ve had many tests reveal areas where panics happen, this has helped us identify and apply correct fixes, to the point where our panics have gone from hundreds to under 50 (the graph above shows the dark red diminishing).\\n\\nFor live tracking of conformance tests you can check [here](https://boa-dev.github.io/boa/test262/). Below is a snapshot of the previous version and today.\\n\\n<div\\n  className=\\"row\\"\\n  style={{ display: \\"flex\\", justifyContent: \\"space-around\\" }}\\n>\\n  <section className=\\"col-md-4\\" id=\\"version-latest\\">\\n    <div className=\\"card\\">\\n      <div className=\\"card-body\\" style={{ padding: \\"10px\\" }}>\\n        <h3>v0.10:</h3>\\n        <ul className=\\"list-group list-group-flush\\">\\n          <li className=\\"list-group-item\\">\\n            Total tests: <span className=\\"total-tests\\">38,706</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Passed tests: <span className=\\"passed-tests\\">6,960</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Ignored tests: <span className=\\"ignored-tests\\">5,748</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Failed tests: <span className=\\"failed-tests\\">25,998</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Conformance: <b>17.98%</b>\\n          </li>\\n        </ul>\\n        <div className=\\"info-link\\">\\n          <a className=\\"card-link\\" href=\\"#\\">\\n            <span className=\\"info-link\\"></span>\\n          </a>\\n        </div>\\n      </div>\\n    </div>\\n  </section>\\n  <section className=\\"col-md-4\\" id=\\"master-latest\\">\\n    <div className=\\"card\\">\\n      <div className=\\"card-body\\" style={{ padding: \\"10px\\" }}>\\n        <h3>v0.11:</h3>\\n        <ul className=\\"list-group list-group-flush\\">\\n          <li className=\\"list-group-item\\">\\n            Total tests: <span className=\\"total-tests\\">78,497</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Passed tests: <span className=\\"passed-tests\\">24,550</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Ignored tests: <span className=\\"ignored-tests\\">15,585</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Failed tests: <span className=\\"failed-tests\\">38,362 (24 â )</span>\\n          </li>\\n          <li className=\\"list-group-item\\">\\n            Conformance: <b>31.28%</b>\\n          </li>\\n        </ul>\\n        <div className=\\"info-link\\">\\n          <a className=\\"card-link\\" href=\\"#\\">\\n            <span className=\\"info-link\\"></span>\\n          </a>\\n        </div>\\n      </div>\\n    </div>\\n  </section>\\n  <section\\n    className=\\"col-md-4\\"\\n    style={{ display: \\"none\\" }}\\n    id=\\"old-versions\\"\\n  ></section>\\n</div>\\n\\n## Regress\\n\\nIn this release Boa switched from its own implementation (wrapping `regex`) to the [`regress`](https://github.com/ridiculousfish/regress) engine for regular expressions. Regress is a crate aiming to implement ECMAScript compliant regular expressions and Boa makes use of (and contributes back to) that.\\n\\nWhile Regress is not 100% spec compliant this is something which is being worked on, also the switch gave us quite a performance boost in our [benchmarks](https://boa-dev.github.io/boa/dev/bench/) we\'re seeing almost 6X faster execution.\\n\\nimport regex_bench_white from \\"./regex-bench-white.png\\";\\nimport regex_bench_dark from \\"./regex-bench-dark.png\\";\\n\\n<ThemedImage\\n  alt=\\"Conformance graph\\"\\n  sources={{\\n    light: regex_bench_white,\\n    dark: regex_bench_dark,\\n  }}\\n/>\\n\\nThe above image shows a big drop in the middle of the graph, above `fb1b8d5` is where we switched over. Conformance went from 19.01% to 18.99% and introduced some panics, however many of those have since been fixed.\\n\\n## Iterating over bytes\\n\\nPreviously the lexer iterated over unicode chars (u32 code points), this wasn\'t strictly neccesary for Boa and we have instead changed the lexer to work over bytes (u8). Iterating over bytes rather than chars is inherently much faster, non-ascii UTF8 bytes are all >=128, and we might only really care about those being correct when parsing idents. This is standard practise amongs lexical analyzers and even browsers read source code byte-by-byte, using the rules of the language\'s syntax to convert the source text into tokens.\\n\\nThis was worked on by @jevancc and his [changes](https://github.com/boa-dev/boa/pull/915/files) have improved performance overall.\\n\\n## Embedding examples\\n\\nWe are still working on what the public API should look like, some of these decisions are driven by feedback and the ever-changing way which Boa works.  \\nNot only you can run Boa against javascript today you can also embed your own objects and classes into the engine before it\'s ran.\\n\\nWe\'ve offered an [example](https://github.com/boa-dev/boa/blob/main/boa/examples/classes.rs) to show how a class can be constructed in Rust then added to the environment before executing your scripts.\\nThis should offer a great insight into how you can interop Rust with JavaScript by using Boa.\\n\\nBelow are some of the more recent functions available from the Context object for you to add your own functionality.\\n\\n```rust\\n// Rust implementation of a function injected into the environment\\nContext::register_global_function(),\\n// Rust implementation of a class injected into the environment\\nContext::register_global_class(),\\n// Rust implementation of a property injected into the environment\\nContext::register_global_property()\\n```\\n\\nIf there are any examples you would like added, please raise an issue on the main repository.\\n\\n## Generating bytecode\\n\\nToday Boa walks the tree of the AST, although easy to implement it\'s not ideal for performance.  \\nWe are looking to do code generation which can then be interpreted. This gradual process may happen over many releases until at some point we can switch implementations under the hood. Our steps are:\\n\\n- ~~Experiment with VM Path on isolated branch~~\\n- ~~Experiment with generating more simpler instructions~~\\n- Build up parity with current implementation\\n- Run test suite over VM path including conformance tests\\n- Switch over once performance is steady\\n- Optimize code generation and intreperter\\n\\n## Thank You\\n\\nEverything in this release has been such a huge effort, we want to thank all the [contributors](https://github.com/boa-dev/boa/graphs/contributors?from=2020-10-02&to=2021-01-12&type=c) in this release, whether it was features, fixes or raising bugs.\\n\\nIf you\'re interested in contributing to Boa, we have some [\\"good first issues\\"](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) and [\\"issues where help is wanted\\"](https://github.com/boa-dev/boa/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22)."},{"id":"/2020/10/02/boa-release-10","metadata":{"permalink":"/blog/2020/10/02/boa-release-10","source":"@site/blog/2020-10-02-boa-release-10/index.md","title":"Boa release v0.10","description":"Boa is an experimental Javascript lexer, parser and compiler written in Rust. It has support for some of the language, can be embedded in Rust projects fairly easily and also used from the command line.","date":"2020-10-02T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":3.46,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","tags":["post"],"title":"Boa release v0.10","authors":"boa-dev","permalink":"2020/10/02/boa-release-10.html"},"unlisted":false,"prevItem":{"title":"Boa release v0.11","permalink":"/blog/2021/01/14/boa-release-11"},"nextItem":{"title":"Boa v0.9: measureme & optimisations","permalink":"/blog/2020/07/03/boa-release-09"}},"content":"Boa is an experimental Javascript lexer, parser and compiler written in Rust. It has support for some of the language, can be embedded in Rust projects fairly easily and also used from the command line.\\nBoa also exists to serve as a Rust implementation of the EcmaScript specification, there will be areas where we can utilise Rust and its fantastic ecosystem to make a fast, concurrent and safe engine.\\n\\nWe have a long way to go, however v0.10 has been the biggest release to date, with 138 issues closed!\\n\\nWe have some highlights, but if you prefer to read the full changelog, you can do that [here](https://github.com/boa-dev/boa/blob/main/CHANGELOG.md)\\n\\n<!--truncate-->\\n\\n## Test262\\n\\nOne question we\'ve been asked for a long time is \\"how conformant are you to the spec?\\". It\'s been tough to answer as we\'ve been unable to run against the official test suite.\\n\\nTest262 is the official ECMAScript Test Suite and exists to provide conformance tests for the latest drafts of the Ecma specification. It is used for all engines, you can even run it in your [browser](https://bakkot.github.io/test262-web-runner/).  \\nThanks to @Razican in v0.10 we now have a test harness that allows us to run it against Boa at any time.\\n\\nThis is a new crate inside the Boa repository that can parse through all of the tests (roughly 40,000 of them) in under 10 minutes and tell us how conformant we are.\\n\\n![image](test262-screenshot.png)\\n\\nToday Boa has <span class=\\"x x-first x-last\\">18</span>% conformity to the specification. We\'ll be keeping an eye on this number over the releases. We expect to achieve around 30% by 0.11 due to some of the fixes we\'re adding which should pass a few thousand tests.\\n\\nThese are run via Github Actions against PRs and for our main branch so that we can keep track of where we are and if there are regressions.\\n\\n## Built-ins\\n\\nWe\'ve added support for [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date), [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) and [well-known symbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol). Supporting Well-known symbols unblocks a lot of work around adding `@@iterators` to some of our global objects which is coming up in the next release.  \\nBoth `Math` and `Number` have had their remaining methods implemented.\\n\\n## Lexer\\n\\nThe lexer has been rebuilt from scratch. Just like the old parser it was a single file before looping through and becoming unmaintainable. Today we\'ve reorganised it into separate modules which know how to lex certain areas. The new lexer [now supports goal symbols](https://github.com/boa-dev/boa/issues/294) and can now tokenize with the correct context at any time.\\n\\n### Goal Symbols\\n\\nOur issue with goal symbols is explained by the V8 team [here](https://v8.dev/blog/understanding-ecmascript-part-3#lexical-grammar)\\n\\nPreviously we weren\'t distinguishing between the contexts where some input elements are permitted and some are not, so lexing `/` would yeild a `division` symbols when it should be a `RegularExpressionLiteral` for example. This change unblocked us being able to run Test262.\\n\\nPerformance wise it is much faster for larger files. The lexer is far more efficient at streaming tokens to the parser than previously so in some scenarios we have big gains.\\n\\n_You can see all the benchmarks [here](https://boa-dev.github.io/boa/dev/bench/)_\\n\\n## Repl syntax highlighting\\n\\nSyntax highlighting was added to the repl this release thanks to @HalidOdat  \\nOur repl is made possible due to the great work of [RustyLine](https://github.com/kkawakam/rustyline)\\n\\n![image](syntaxHighlighting.gif)\\n\\n## Looking forward\\n\\nThere are plenty of fixes and performance changes still needed, we also hope to experiment with producing Bytecode from our AST in future. Test262 coverage will almost certainly increase, and we are polishing the public API for easier use when embedding into other Rust projects.\\n\\nThanks to all those who contributed to 0.10, you can see the names in the full changelog linked above.\\n\\nYou can checkout Boa via [Github](https://github.com/boa-dev/boa) or on [crates.io](https://crates.io/crates/Boa)"},{"id":"/2020/07/03/boa-release-09","metadata":{"permalink":"/blog/2020/07/03/boa-release-09","source":"@site/blog/2020-07-03-boa-release-09/index.md","title":"Boa v0.9: measureme & optimisations","description":"Hello World!","date":"2020-07-03T00:00:00.000Z","tags":[{"inline":true,"label":"post","permalink":"/blog/tags/post"}],"readingTime":5.73,"hasTruncateMarker":true,"authors":[{"name":"Boa Developers","url":"https://github.com/boa-dev","key":"boa-dev","page":null}],"frontMatter":{"layout":"post","title":"Boa v0.9: measureme & optimisations","authors":"boa-dev","tags":["post"],"permalink":"2020/07/03/boa-release-09.html"},"unlisted":false,"prevItem":{"title":"Boa release v0.10","permalink":"/blog/2020/10/02/boa-release-10"}},"content":"Hello World!\\n\\nBoa is an experimental Javascript lexer, parser and compiler written in Rust. It has support for some of the language, can be embedded in Rust projects fairly easily and also used from the command line.  \\nBoa also exists to serve as a Rust implementation of the EcmaScript specification, there will be areas where we can utilise Rust and its fantastic ecosystem to make a fast, concurrent and safe engine.\\n\\nToday we\'re pleased to announce our latest release, version 0.9.  \\nv0.9 is by far the biggest release we\'ve had since Boa began. You can find the full changes from the [changelog](https://github.com/boa-dev/boa/blob/main/CHANGELOG.md#-090-2020-06-25---move-to-organisation-78-faster-execution-time). The milestone behind this version was further optimisation and an increase in new features. We can show you how we can identify areas that can be optimised.\\n\\n<!--truncate-->\\n\\n## Better tooling for profiling\\n\\nBoa became the first Rust project to make use of [measureme](https://github.com/rust-lang/measureme), a profiling tool built from the ground up for Rust. This was only used by the Rust team themselves to profile the compiler. We managed to work with the compiler team to get the framework in a good enough state to be used by other projects too, and in this release, we gave it a try.\\n\\nMeasure me lets you profile various areas of your choosing, then you can generate a trace file which can be loaded into Chromium or various other tools for analysis.\\nWe took it for a spin (which you\'ll see in Object Specialization).\\n\\nBelow is an example of our trace, this is using a measureme tool called `summarize`\\n\\n```\\n+----------------------------+-----------+-----------------+----------+------------+\\n| Item                       | Self time | % of total time | Time     | Item count |\\n+----------------------------+-----------+-----------------+----------+------------+\\n| From<Object>               | 1.04ms    | 14.776          | 1.04ms   | 146        |\\n+----------------------------+-----------+-----------------+----------+------------+\\n| new_object                 | 356.50Âµs  | 5.082           | 533.50Âµs | 18         |\\n+----------------------------+-----------+-----------------+----------+------------+\\n| create_instrinsics         | 263.50Âµs  | 3.756           | 6.38ms   | 1          |\\n+----------------------------+-----------+-----------------+----------+------------+\\n| make_builtin_fn: toString  | 218.50Âµs  | 3.114           | 290.50Âµs | 12         |\\n+----------------------------+-----------+-----------------+----------+------------+\\n| String                     | 81.60Âµs   | 1.163           | 961.60Âµs | 1          |\\n+----------------------------+-----------+-----------------+----------+------------+\\n```\\n\\nYou can read more about Rust\'s usage of measureme [here](https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html).\\n\\n## Object Specialization\\n\\nIn JavaScript internal metadata for objects are stored in `internal slots`. In Boa we stored internal slots as a hashmap tied to the object, with the keys being strings and the values as [`JSValues`](https://github.com/boa-dev/boa/blob/73f65f7800917c92f86134eaa21751c1ca93d986/boa/src/builtins/value/mod.rs#L57-L78). This meant we needed to constantly unwrap them into a Rust primitive to access the data. Secondly we were restricted as to what type of data we could put in internal slots. For example, lets say we want to implement [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) by using the native [`HashSet`](https://doc.rust-lang.org/std/collections/struct.HashSet.html) as a backing store, this would not be possible.\\n\\nBy changing how internal data is handled for some of our builtin objects and removing a whole bunch of redundant access checks, we managed to speed up the interpreter.\\n\\nBoa would spend a significant amount of time converting back and forth between JS Values and primitive values. We found a huge amount of time was spent in `Value::set_field` before any code had even been executed. `set_field` was slow due to the amount of updating of internal slots as part of setting up. Here you can see realm creation takes roughly 60ms (dev build).\\n\\n_We use [Crox](https://github.com/rust-lang/measureme/blob/main/crox/Readme.md) to convert our measureme data into a format Chrome\'s performance tab understands_\\n\\n![Before](before.png)\\n\\nWe refactored many builtins to hold an `ObjectData` enum variant instead, some of which can hold a value for the type also.\\nThis can be used to both identify objects and to use their internal data.  \\nHere is an example of our enum.\\n\\n```rust\\n/// Defines the different types of objects.\\n#[derive(Debug, Trace, Finalize, Clone)]\\npub enum ObjectData {\\n    Array,\\n    BigInt(RcBigInt),\\n    Boolean(bool),\\n    Function(Function),\\n    String(RcString),\\n    Number(f64),\\n    Symbol(RcSymbol),\\n    Error,\\n    Ordinary,\\n}\\n```\\n\\n![After](after.png)\\n\\nThis gave us a 70% speedup and reduced startup time by well over half. The `realm::create` function now runs in 13ms instead of 60ms.\\n\\n## Optimised Type Comparisons\\n\\nIf you\'ve ever called `typeof` in JavaScript, you get a string value describing the primitive type of it\'s argument. Boa was doing the same internally for comparing (using the \\"get_type()\\" call), however getting the string value from each primitive then comparing them is not very performant.  \\nNow, thanks to @Lan2u we have a rust [`Type`](https://github.com/boa-dev/boa/blob/8f8498eac17164c8de2f599bd0b7ba2e8053ec30/boa/src/builtins/value/val_type.rs#L4-L17) enum which makes comparing more efficient and on average brings another 8% performance boost.\\n\\n## JSValue Refactor\\n\\nWe have completely refactored how JavaScript values are stored.  \\n[#498](https://github.com/boa-dev/boa/pull/498) makes values more lightweight by only GC\'ing objects and not the primitives. The primitive scalar values are just Rust primitives which implement the Copy trait, so the overhead of moving these around is much lower.  \\nBy decoupling our `Value` types and `GC` types we have brought our `Value` size from 40 bytes => 24 bytes and an 80% reduction in arithmetic operations!\\n\\n## Parser rebuild, better code organisation\\n\\nBoa was predominantly 3 files. The lexer, parser and interpreter.  \\nThe naive implementation of the parser was a [single file](https://github.com/boa-dev/boa/blob/c23a7b1f4ac57af6c5f0b9f6c98fbbed7a14c98f/src/lib/syntax/parser.rs) which had a long match expression for tokens and went through every token figuring out what to do. This did the job but became unmaintainable when adding new features.  \\nWe have been breaking the parser up into separate modules, which represent various expressions and statements that conform to the specification. (more about this in a future post).\\n\\nAfter all the fixes in this release we\'ve seen on average a 70% improvement, we still have areas where we plan to improve. We are currently rebuilding the lexer so it is more broken up like the parser and interpreter, we will blog about this soon in future.\\n\\n## Roadmap\\n\\n### _How much of the specification is covered?_\\n\\nOur next milestone is to tidy up the lexer so it takes into account [`goal symbols`](https://tc39.es/ecma262/#sec-context-free-grammars) then we plan to start running Test 262, the official ECMAScript Test Suite. It has a lot of tests (over 29272 test files) and will tell us in detail which parts of the specification need work.  \\nThere are also large items like classes which are still not covered, however, these should now be easier to implement with parsing broken up.\\n\\n### _Public API_\\n\\n[#445](https://github.com/boa-dev/boa/issues/445) looks to improve the public API too so Rust projects can interactive with Boa more easily.  \\nIt should be possible today to just use the lexer, parser or the whole execution path.\\n\\nWe hope to add more detail in future on how some parts of Boa work, make sure you stay tuned for any future posts!"}]}}');

/***/ })

}]);