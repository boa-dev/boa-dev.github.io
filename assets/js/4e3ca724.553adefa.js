"use strict";(self.webpackChunkboajs_dev=self.webpackChunkboajs_dev||[]).push([[5518],{3621:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>h});var n=o(4848),r=o(8453);const s={sidebar_position:2},a="Shapes (Hidden Classes)",i={id:"optimizations/shapes",title:"Shapes (Hidden Classes)",description:"The best way to explain object shapes is through examples. It all begins with the root shape.",source:"@site/docs/optimizations/shapes.md",sourceDirName:"optimizations",slug:"/optimizations/shapes",permalink:"/docs/optimizations/shapes",draft:!1,unlisted:!1,editUrl:"https://github.com/boa-dev/boa-dev.github.io/tree/main/docs/docs/optimizations/shapes.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"infoSidebar",previous:{title:"Overview",permalink:"/docs/optimizations/overview"},next:{title:"Profiling",permalink:"/docs/profiling"}},l={},h=[];function p(e){const t={code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"shapes-hidden-classes",children:"Shapes (Hidden Classes)"}),"\n",(0,n.jsx)(t.p,{children:"The best way to explain object shapes is through examples. It all begins with the root shape."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-mermaid",children:"flowchart LR\n    classDef New style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style Root stroke:#000,stroke-width:5px\n    style PropertyTable fill:#071E22\n\n    Root(<b>Root Shape</b>\\n<b>Prototype:</i> <i>None</i>) --\x3e| Property Count 0 | PropertyTable(PropertyTable\\n)\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The root shape is where the transition chain starts from, it has a pointer to a ",(0,n.jsx)(t.code,{children:"PropertyTable"}),",\nwe will explain what it is and does later on!"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"NOTE:"})," We will annotate the shapes with ",(0,n.jsx)(t.code,{children:"S"})," followed by a number."]}),"\n",(0,n.jsx)(t.p,{children:"If we have an example of JavaScript code like:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"let o = {};\n"})}),"\n",(0,n.jsx)(t.p,{children:"The following chain is created:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-mermaid",children:"flowchart LR\n    classDef New style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style Root stroke:#000,stroke-width:5px\n    style PropertyTable fill:#071E22\n\n    Root(<b>S0: Root Shape</b>\\n<b>Prototype:</b> <i>None</i>) --\x3e|Property Count: 0| PropertyTable(PropertyTable\\n)\n\n    ObjectPrototype(<b>S1: Prototype Shape</b>\\n<b>Prototype:</b> Object.prototype) --\x3e|Property Count: 0|PropertyTable\n    ObjectPrototype:::New --\x3e|Previous| Root\n"})}),"\n",(0,n.jsxs)(t.p,{children:["We transition, the object ",(0,n.jsx)(t.code,{children:"o"})," has ",(0,n.jsx)(t.code,{children:"S1"})," shape. The root shape does not have a prototype. So we transition into a shape that has the\n",(0,n.jsx)(t.code,{children:"Object.prototype"})," as ",(0,n.jsx)(t.code,{children:"__proto__"}),". We can see that the shapes inherited the ",(0,n.jsx)(t.code,{children:"PropertyTable"})," from the ",(0,n.jsx)(t.code,{children:"root"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Ok, Let us add a property ",(0,n.jsx)(t.code,{children:"x"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"o.x = 100; // The value is not important!\n"})}),"\n",(0,n.jsx)(t.p,{children:"Then this happens:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-mermaid",children:"flowchart LR\n    classDef New style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style Root stroke:#000,stroke-width:5px\n    style PropertyTable fill:#071E22\n\n    Root(<b>S0: Root Shape</b>\\nPrototype: <i>None</i>) --\x3e|Property Count: 0| PropertyTable(<b>PropertyTable</b>\\nx: Slot 0, writable, configurable, enumerable)\n\n    ObjectPrototype(<b>S1: Prototype Shape</b>\\n<b>Prototype:</b> <i>Object.prototype</i>) --\x3e|Property Count: 0|PropertyTable\n    ObjectPrototype --\x3e|Previous| Root\n\n    InsertX(<b>S2: Insert Shape</b>\\n<b>Property:</b> '<i>x</i>') --\x3e |Property Count: 1|PropertyTable\n    InsertX:::New --\x3e|Previous| ObjectPrototype\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The object ",(0,n.jsx)(t.code,{children:"o"})," has shape ",(0,n.jsx)(t.code,{children:"S2"})," shape now, we can see that it also inherited the ",(0,n.jsx)(t.code,{children:"PropertyTable"}),", but it's property count is ",(0,n.jsx)(t.code,{children:"1"})," and\nan entry has been added into the ",(0,n.jsx)(t.code,{children:"PropertyTable"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["We can see that the property added is ",(0,n.jsx)(t.code,{children:"writable"}),", ",(0,n.jsx)(t.code,{children:"configurable"}),", and ",(0,n.jsx)(t.code,{children:"enumerable"}),", but we also see ",(0,n.jsx)(t.code,{children:"Slot 0"}),",\nthis is the index into the dense storage in the object itself."]}),"\n",(0,n.jsxs)(t.p,{children:["Here is how it would look with the ",(0,n.jsx)(t.code,{children:"o"})," object:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-mermaid",children:"flowchart LR\n    classDef New style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style Root stroke:#000,stroke-width:5px\n    style PropertyTable fill:#071E22\n\n    Root(<b>S0: Root Shape</b>\\n<b>Prototype:</b> <i>None</i>) --\x3e| Property Count: 0 | PropertyTable(<b>PropertyTable</b>\\nx: Slot 0, writable, configurable, enumerable)\n\n    ObjectPrototype(<b>S1: Prototype Shape</b>\\n<b>Prototype:</b> <i>Object.prototype</i>) --\x3e| Property Count: 0 |PropertyTable\n    ObjectPrototype --\x3e|Previous| Root\n\n    InsertX(<b>S2: Insert Shape</b>\\n<b>Property:</b> '<i>x</i>') --\x3e | Property Count: 1 | PropertyTable\n    InsertX --\x3e|Previous| ObjectPrototype\n\n    O(<b>Object o</b>\\n<b>Element 0:</b> JsValue: <i>100</i>)\n    O:::New --\x3e InsertX\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Let's define a getter and setter ",(0,n.jsx)(t.code,{children:"y"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:'// What the getter/setter are not important!\nObject.defineProperty(o, "y", {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return this.x;\n  },\n  set: function (value) {\n    this.x = value;\n  },\n});\n'})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-mermaid",children:"flowchart LR\n    classDef New style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style Root stroke:#000,stroke-width:5px\n    style PropertyTable fill:#071E22\n\n    Root(<b>S0: Root Shape</b>\\n<b>Prototype:</b> <i>None</i>) --\x3e|Property Count: 0| PropertyTable(<b>PropertyTable</b>\\nx: Slot 0, writable, configurable, enumerable\\ny: Slot 1, has_get, has_set, configurable, enumerable)\n\n    ObjectPrototype(<b>S1: Prototype Shape</b>\\n<b>Prototype:</b> <i>Object.prototype</i>) --\x3e| Property Count: 0 |PropertyTable\n    ObjectPrototype --\x3e|Previous| Root\n\n    InsertX(<b>S2: Insert Shape</b>\\n<b>Property:</b> '<i>x</i>') --\x3e |Property Count: 1| PropertyTable\n    InsertX --\x3e|Previous| ObjectPrototype\n\n    InsertY(<b>S3: Insert Shape</b>\\n<b>Property:</b> '<i>y</i>') --\x3e |Property Count: 2| PropertyTable\n    InsertY:::New --\x3e|Previous| InsertX\n\n    O(<b>Object o\\nElement 0:</b> JsValue: 100\\n<b>Element 1:</b> JsValue: func\\n<b>Element 2:</b> JsValue: func) --\x3e InsertY\n"})}),"\n",(0,n.jsxs)(t.p,{children:["We can see that the property has been added into the property table, it has the ",(0,n.jsx)(t.code,{children:"has_get"})," and ",(0,n.jsx)(t.code,{children:"has_set"})," flags set,\nin the object there are two elements added, the first is the ",(0,n.jsx)(t.code,{children:"get"})," function and the second is the ",(0,n.jsx)(t.code,{children:"set"})," function."]}),"\n",(0,n.jsx)(t.p,{children:"Slots are varying in length, two for accessor properties and one for data properties, the index points to the first\nvalue in the object storage."}),"\n",(0,n.jsxs)(t.p,{children:["What would happen if an object had ",(0,n.jsx)(t.code,{children:"S2"})," shape and we tried to access a property ",(0,n.jsx)(t.code,{children:"y"})," how does it know if it\nhas or doesn't have a property named ",(0,n.jsx)(t.code,{children:"y"}),"? By the property count on the shape, it has property count ",(0,n.jsx)(t.code,{children:"1"}),",\nall the object in the ",(0,n.jsx)(t.code,{children:"PropertyTable"})," are stored in a map that preserves the order and and can be indexed."]}),"\n",(0,n.jsxs)(t.p,{children:["When we do a lookup the on property table, if the index of the property is greater than the property count (",(0,n.jsx)(t.code,{children:"1"}),"),\nthan it does not belong to the shape."]}),"\n",(0,n.jsxs)(t.p,{children:["Now, Let's create a new object ",(0,n.jsx)(t.code,{children:"o2"}),", with property ",(0,n.jsx)(t.code,{children:"x"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"let o2 = { x: 200 };\n"})}),"\n",(0,n.jsxs)(t.p,{children:["After this ",(0,n.jsx)(t.code,{children:"o2"})," would have the ",(0,n.jsx)(t.code,{children:"S2"})," shape."]}),"\n",(0,n.jsxs)(t.p,{children:["How does the shape know that it can reuse ",(0,n.jsx)(t.code,{children:"S1"})," then to go to ",(0,n.jsx)(t.code,{children:"S2"}),"? This is not the real structure!\nEvery shape has pointers to forward transitions that happened, these are weak pointers so we don't keep\nalive unused shapes. The pointers have been omitted, so the diagrams are clearer (too many arrows)."]}),"\n",(0,n.jsxs)(t.p,{children:["Ok, now let us define a property ",(0,n.jsx)(t.code,{children:"z"})," instead of ",(0,n.jsx)(t.code,{children:"y"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"o2.z = 300;\n"})}),"\n",(0,n.jsx)(t.p,{children:"The following changes accure to the shape tree:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-mermaid",children:"flowchart LR\n    classDef New style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style Root stroke:#000,stroke-width:5px\n    style PropertyTable fill:#071E22\n    style PropertyTableFork fill:#071E22\n\n    Root(<b>S0: Root Shape</b>\\n<b>Prototype:</b> <i>None</i>) --\x3e| Property Count: 0 | PropertyTable(<b>PropertyTable</b>\\nx: Slot 0, writable, configurable, enumerable\\ny: Slot 1, has_get, has_set, configurable, enumerable)\n\n    ObjectPrototype(<b>S1: Prototype Shape\\nPrototype:</b> <i>Object.prototype</i>) --\x3e| Property Count: 0 |PropertyTable\n    ObjectPrototype --\x3e|Previous| Root\n\n    InsertX(<b>S2: Insert Shape\\nProperty:</b> '<i>x</i>') --\x3e | Property Count: 1 | PropertyTable\n    InsertX --\x3e|Previous| ObjectPrototype\n\n    InsertY(<b>S3: Insert Shape\\nProperty:</b> '<i>y</i>') --\x3e | Property Count: 2 | PropertyTable\n    InsertY --\x3e|Previous| InsertX\n\n    PropertyTableFork(<b>PropertyTable</b>\\nx: Slot 0, writable, configurable, enumerable\\nz: Slot 1, writable, configurable, enumerable)\n    InsertZ(<b>S4: Insert Shape\\nProperty:</b> '<i>z</i>') --\x3e | Property Count: 2 | PropertyTableFork:::New\n    InsertZ:::New --\x3e|Previous| InsertX\n\n    O(<b>Object o\\nElement 0:</b> JsValue: 100\\n<b>Element 1:</b> JsValue: func\\n<b>Element 2:</b> JsValue: func) --\x3e InsertY\n    O2(<b>Object o2\\nElement 0:</b> JsValue: 200\\n<b>Element 1:</b> JsValue: 300)\n    O2:::New --\x3e InsertZ\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Now ",(0,n.jsx)(t.code,{children:"o2"})," has ",(0,n.jsx)(t.code,{children:"S4"})," shape. We can also see that ",(0,n.jsx)(t.code,{children:"PropertyTable"})," has been forked, because we can no longer add a property at position ",(0,n.jsx)(t.code,{children:"1"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["What would happen if we wanted to delete a property ",(0,n.jsx)(t.code,{children:"x"})," from object ",(0,n.jsx)(t.code,{children:"o"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"delete o.x;\n"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-mermaid",children:"flowchart LR\n    classDef New style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style Root stroke:#000,stroke-width:5px\n    style PropertyTable fill:#071E22\n    style PropertyTableFork fill:#071E22\n\n    Root(<b>S0: Root Shape</b>\\n<b>Prototype:</b> <i>None</i>) --\x3e| Property Count: 0 | PropertyTable(<b>PropertyTable</b>\\nx: Slot 0, writable, configurable, enumerable\\ny: Slot 1, has_get, has_set, configurable, enumerable)\n\n    ObjectPrototype(<b>S1: Prototype Shape\\nPrototype:</b> <i>Object.prototype</i>) --\x3e| Property Count: 0 |PropertyTable\n    ObjectPrototype --\x3e|Previous| Root\n\n\n    PropertyTableFork(<b>PropertyTable</b>\\ny: Slot 0, has_get, has_set, configurable, enumerable)\n    InsertYNew(<b>S3: Insert Shape\\nProperty:</b> <i>y</i>) --\x3e | Property Count: 1 |PropertyTableFork:::New\n    InsertYNew:::New --\x3e|Previous| ObjectPrototype\n\n    O(<b>Object o</b>\\n<b>Element 0:</b> JsValue: func\\n<b>Element 1:</b> JsValue: func) --\x3e InsertYNew\n    O:::New\n"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"NOTE:"}),": ",(0,n.jsx)(t.code,{children:"o2"})," and its shape have been omitted from the diagram."]}),"\n",(0,n.jsxs)(t.p,{children:["When a deletion happens, we find the node in the chain where we added the property, and get it's parent (",(0,n.jsx)(t.code,{children:"base"}),"),\nwe also remember that what transitions happened after the property insertion, then we apply them\none by one until we construct the chain and return the last shape in that chain."]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>i});var n=o(6540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);