"use strict";(self.webpackChunkboajs_dev=self.webpackChunkboajs_dev||[]).push([[9522],{5480:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var o=a(4848),s=a(8453);const n={layout:"post",title:"Boa v0.9: measureme & optimisations",author:"Boa Developers",tags:["post"],permalink:"2020/07/03/boa-release-09.html"},i=void 0,r={permalink:"/blog/2020/07/03/boa-release-09",source:"@site/blog/2020-07-03-boa-release-09/index.md",title:"Boa v0.9: measureme & optimisations",description:"Hello World!",date:"2020-07-03T00:00:00.000Z",formattedDate:"July 3, 2020",tags:[{label:"post",permalink:"/blog/tags/post"}],readingTime:5.345,hasTruncateMarker:!1,authors:[{name:"Boa Developers"}],frontMatter:{layout:"post",title:"Boa v0.9: measureme & optimisations",author:"Boa Developers",tags:["post"],permalink:"2020/07/03/boa-release-09.html"},unlisted:!1,prevItem:{title:"Boa release v0.10",permalink:"/blog/2020/10/02/boa-release-10"}},l={authorsImageUrls:[void 0]},c=[{value:"Better tooling for profiling",id:"better-tooling-for-profiling",level:2},{value:"Object Specialization",id:"object-specialization",level:2},{value:"Optimised Type Comparisons",id:"optimised-type-comparisons",level:2},{value:"JSValue Refactor",id:"jsvalue-refactor",level:2},{value:"Parser rebuild, better code organisation",id:"parser-rebuild-better-code-organisation",level:2},{value:"Roadmap",id:"roadmap",level:2},{value:"<em>How much of the specification is covered?</em>",id:"how-much-of-the-specification-is-covered",level:3},{value:"<em>Public API</em>",id:"public-api",level:3}];function h(e){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Hello World!"}),"\n",(0,o.jsxs)(t.p,{children:["Boa is an experimental Javascript lexer, parser and compiler written in Rust. It has support for some of the language, can be embedded in Rust projects fairly easily and also used from the command line.",(0,o.jsx)(t.br,{}),"\n","Boa also exists to serve as a Rust implementation of the EcmaScript specification, there will be areas where we can utilise Rust and its fantastic ecosystem to make a fast, concurrent and safe engine."]}),"\n",(0,o.jsxs)(t.p,{children:["Today we're pleased to announce our latest release, version 0.9.",(0,o.jsx)(t.br,{}),"\n","v0.9 is by far the biggest release we've had since Boa began. You can find the full changes from the ",(0,o.jsx)(t.a,{href:"https://github.com/boa-dev/boa/blob/main/CHANGELOG.md#-090-2020-06-25---move-to-organisation-78-faster-execution-time",children:"changelog"}),". The milestone behind this version was further optimisation and an increase in new features. We can show you how we can identify areas that can be optimised."]}),"\n",(0,o.jsx)(t.h2,{id:"better-tooling-for-profiling",children:"Better tooling for profiling"}),"\n",(0,o.jsxs)(t.p,{children:["Boa became the first Rust project to make use of ",(0,o.jsx)(t.a,{href:"https://github.com/rust-lang/measureme",children:"measureme"}),", a profiling tool built from the ground up for Rust. This was only used by the Rust team themselves to profile the compiler. We managed to work with the compiler team to get the framework in a good enough state to be used by other projects too, and in this release, we gave it a try."]}),"\n",(0,o.jsx)(t.p,{children:"Measure me lets you profile various areas of your choosing, then you can generate a trace file which can be loaded into Chromium or various other tools for analysis.\nWe took it for a spin (which you'll see in Object Specialization)."}),"\n",(0,o.jsxs)(t.p,{children:["Below is an example of our trace, this is using a measureme tool called ",(0,o.jsx)(t.code,{children:"summarize"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"+----------------------------+-----------+-----------------+----------+------------+\n| Item                       | Self time | % of total time | Time     | Item count |\n+----------------------------+-----------+-----------------+----------+------------+\n| From<Object>               | 1.04ms    | 14.776          | 1.04ms   | 146        |\n+----------------------------+-----------+-----------------+----------+------------+\n| new_object                 | 356.50\xb5s  | 5.082           | 533.50\xb5s | 18         |\n+----------------------------+-----------+-----------------+----------+------------+\n| create_instrinsics         | 263.50\xb5s  | 3.756           | 6.38ms   | 1          |\n+----------------------------+-----------+-----------------+----------+------------+\n| make_builtin_fn: toString  | 218.50\xb5s  | 3.114           | 290.50\xb5s | 12         |\n+----------------------------+-----------+-----------------+----------+------------+\n| String                     | 81.60\xb5s   | 1.163           | 961.60\xb5s | 1          |\n+----------------------------+-----------+-----------------+----------+------------+\n"})}),"\n",(0,o.jsxs)(t.p,{children:["You can read more about Rust's usage of measureme ",(0,o.jsx)(t.a,{href:"https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html",children:"here"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"object-specialization",children:"Object Specialization"}),"\n",(0,o.jsxs)(t.p,{children:["In JavaScript internal metadata for objects are stored in ",(0,o.jsx)(t.code,{children:"internal slots"}),". In Boa we stored internal slots as a hashmap tied to the object, with the keys being strings and the values as ",(0,o.jsx)(t.a,{href:"https://github.com/boa-dev/boa/blob/73f65f7800917c92f86134eaa21751c1ca93d986/boa/src/builtins/value/mod.rs#L57-L78",children:(0,o.jsx)(t.code,{children:"JSValues"})}),". This meant we needed to constantly unwrap them into a Rust primitive to access the data. Secondly we were restricted as to what type of data we could put in internal slots. For example, lets say we want to implement ",(0,o.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",children:(0,o.jsx)(t.code,{children:"Set"})})," by using the native ",(0,o.jsx)(t.a,{href:"https://doc.rust-lang.org/std/collections/struct.HashSet.html",children:(0,o.jsx)(t.code,{children:"HashSet"})})," as a backing store, this would not be possible."]}),"\n",(0,o.jsx)(t.p,{children:"By changing how internal data is handled for some of our builtin objects and removing a whole bunch of redundant access checks, we managed to speed up the interpreter."}),"\n",(0,o.jsxs)(t.p,{children:["Boa would spend a significant amount of time converting back and forth between JS Values and primitive values. We found a huge amount of time was spent in ",(0,o.jsx)(t.code,{children:"Value::set_field"})," before any code had even been executed. ",(0,o.jsx)(t.code,{children:"set_field"})," was slow due to the amount of updating of internal slots as part of setting up. Here you can see realm creation takes roughly 60ms (dev build)."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:["We use ",(0,o.jsx)(t.a,{href:"https://github.com/rust-lang/measureme/blob/main/crox/Readme.md",children:"Crox"})," to convert our measureme data into a format Chrome's performance tab understands"]})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Before",src:a(3916).A+"",width:"1279",height:"1002"})}),"\n",(0,o.jsxs)(t.p,{children:["We refactored many builtins to hold an ",(0,o.jsx)(t.code,{children:"ObjectData"})," enum variant instead, some of which can hold a value for the type also.\nThis can be used to both identify objects and to use their internal data.",(0,o.jsx)(t.br,{}),"\n","Here is an example of our enum."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// Defines the different types of objects.\n#[derive(Debug, Trace, Finalize, Clone)]\npub enum ObjectData {\n    Array,\n    BigInt(RcBigInt),\n    Boolean(bool),\n    Function(Function),\n    String(RcString),\n    Number(f64),\n    Symbol(RcSymbol),\n    Error,\n    Ordinary,\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"After",src:a(9931).A+"",width:"1280",height:"1005"})}),"\n",(0,o.jsxs)(t.p,{children:["This gave us a 70% speedup and reduced startup time by well over half. The ",(0,o.jsx)(t.code,{children:"realm::create"})," function now runs in 13ms instead of 60ms."]}),"\n",(0,o.jsx)(t.h2,{id:"optimised-type-comparisons",children:"Optimised Type Comparisons"}),"\n",(0,o.jsxs)(t.p,{children:["If you've ever called ",(0,o.jsx)(t.code,{children:"typeof"}),' in JavaScript, you get a string value describing the primitive type of it\'s argument. Boa was doing the same internally for comparing (using the "get_type()" call), however getting the string value from each primitive then comparing them is not very performant.',(0,o.jsx)(t.br,{}),"\n","Now, thanks to @Lan2u we have a rust ",(0,o.jsx)(t.a,{href:"https://github.com/boa-dev/boa/blob/8f8498eac17164c8de2f599bd0b7ba2e8053ec30/boa/src/builtins/value/val_type.rs#L4-L17",children:(0,o.jsx)(t.code,{children:"Type"})})," enum which makes comparing more efficient and on average brings another 8% performance boost."]}),"\n",(0,o.jsx)(t.h2,{id:"jsvalue-refactor",children:"JSValue Refactor"}),"\n",(0,o.jsxs)(t.p,{children:["We have completely refactored how JavaScript values are stored.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.a,{href:"https://github.com/boa-dev/boa/pull/498",children:"#498"})," makes values more lightweight by only GC'ing objects and not the primitives. The primitive scalar values are just Rust primitives which implement the Copy trait, so the overhead of moving these around is much lower.",(0,o.jsx)(t.br,{}),"\n","By decoupling our ",(0,o.jsx)(t.code,{children:"Value"})," types and ",(0,o.jsx)(t.code,{children:"GC"})," types we have brought our ",(0,o.jsx)(t.code,{children:"Value"})," size from 40 bytes => 24 bytes and an 80% reduction in arithmetic operations!"]}),"\n",(0,o.jsx)(t.h2,{id:"parser-rebuild-better-code-organisation",children:"Parser rebuild, better code organisation"}),"\n",(0,o.jsxs)(t.p,{children:["Boa was predominantly 3 files. The lexer, parser and interpreter.",(0,o.jsx)(t.br,{}),"\n","The naive implementation of the parser was a ",(0,o.jsx)(t.a,{href:"https://github.com/boa-dev/boa/blob/c23a7b1f4ac57af6c5f0b9f6c98fbbed7a14c98f/src/lib/syntax/parser.rs",children:"single file"})," which had a long match expression for tokens and went through every token figuring out what to do. This did the job but became unmaintainable when adding new features.",(0,o.jsx)(t.br,{}),"\n","We have been breaking the parser up into separate modules, which represent various expressions and statements that conform to the specification. (more about this in a future post)."]}),"\n",(0,o.jsx)(t.p,{children:"After all the fixes in this release we've seen on average a 70% improvement, we still have areas where we plan to improve. We are currently rebuilding the lexer so it is more broken up like the parser and interpreter, we will blog about this soon in future."}),"\n",(0,o.jsx)(t.h2,{id:"roadmap",children:"Roadmap"}),"\n",(0,o.jsx)(t.h3,{id:"how-much-of-the-specification-is-covered",children:(0,o.jsx)(t.em,{children:"How much of the specification is covered?"})}),"\n",(0,o.jsxs)(t.p,{children:["Our next milestone is to tidy up the lexer so it takes into account ",(0,o.jsx)(t.a,{href:"https://tc39.es/ecma262/#sec-context-free-grammars",children:(0,o.jsx)(t.code,{children:"goal symbols"})})," then we plan to start running Test 262, the official ECMAScript Test Suite. It has a lot of tests (over 29272 test files) and will tell us in detail which parts of the specification need work.",(0,o.jsx)(t.br,{}),"\n","There are also large items like classes which are still not covered, however, these should now be easier to implement with parsing broken up."]}),"\n",(0,o.jsx)(t.h3,{id:"public-api",children:(0,o.jsx)(t.em,{children:"Public API"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://github.com/boa-dev/boa/issues/445",children:"#445"})," looks to improve the public API too so Rust projects can interactive with Boa more easily.",(0,o.jsx)(t.br,{}),"\n","It should be possible today to just use the lexer, parser or the whole execution path."]}),"\n",(0,o.jsx)(t.p,{children:"We hope to add more detail in future on how some parts of Boa work, make sure you stay tuned for any future posts!"})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},9931:(e,t,a)=>{a.d(t,{A:()=>o});const o=a.p+"assets/images/after-114754df50c9a05fc0eec4fabcac2bd0.png"},3916:(e,t,a)=>{a.d(t,{A:()=>o});const o=a.p+"assets/images/before-b541b61e85c78e35de4900cda09fae1c.png"},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>r});var o=a(6540);const s={},n=o.createContext(s);function i(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);