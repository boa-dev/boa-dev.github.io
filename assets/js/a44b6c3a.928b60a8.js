"use strict";(self.webpackChunkboajs_dev=self.webpackChunkboajs_dev||[]).push([[6803],{7515:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var a=s(4848),n=s(8453);const o={layout:"post",tags:["post"],title:"Boa release v0.10",author:"Boa Developers",permalink:"2020/10/02/boa-release-10.html"},i=void 0,r={permalink:"/blog/2020/10/02/boa-release-10",source:"@site/blog/2020-10-02-boa-release-10/index.md",title:"Boa release v0.10",description:"Boa is an experimental Javascript lexer, parser and compiler written in Rust. It has support for some of the language, can be embedded in Rust projects fairly easily and also used from the command line.",date:"2020-10-02T00:00:00.000Z",formattedDate:"October 2, 2020",tags:[{label:"post",permalink:"/blog/tags/post"}],readingTime:3.04,hasTruncateMarker:!1,authors:[{name:"Boa Developers"}],frontMatter:{layout:"post",tags:["post"],title:"Boa release v0.10",author:"Boa Developers",permalink:"2020/10/02/boa-release-10.html"},unlisted:!1,prevItem:{title:"Boa release v0.11",permalink:"/blog/2021/01/14/boa-release-11"},nextItem:{title:"Boa v0.9: measureme & optimisations",permalink:"/blog/2020/07/03/boa-release-09"}},l={authorsImageUrls:[void 0]},h=[{value:"Test262",id:"test262",level:2},{value:"Built-ins",id:"built-ins",level:2},{value:"Lexer",id:"lexer",level:2},{value:"Goal Symbols",id:"goal-symbols",level:3},{value:"Repl syntax highlighting",id:"repl-syntax-highlighting",level:2},{value:"Looking forward",id:"looking-forward",level:2}];function c(e){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Boa is an experimental Javascript lexer, parser and compiler written in Rust. It has support for some of the language, can be embedded in Rust projects fairly easily and also used from the command line.\nBoa also exists to serve as a Rust implementation of the EcmaScript specification, there will be areas where we can utilise Rust and its fantastic ecosystem to make a fast, concurrent and safe engine."}),"\n",(0,a.jsx)(t.p,{children:"We have a long way to go, however v0.10 has been the biggest release to date, with 138 issues closed!"}),"\n",(0,a.jsxs)(t.p,{children:["We have some highlights, but if you prefer to read the full changelog, you can do that ",(0,a.jsx)(t.a,{href:"https://github.com/boa-dev/boa/blob/main/CHANGELOG.md",children:"here"})]}),"\n",(0,a.jsx)(t.h2,{id:"test262",children:"Test262"}),"\n",(0,a.jsx)(t.p,{children:"One question we've been asked for a long time is \"how conformant are you to the spec?\". It's been tough to answer as we've been unable to run against the official test suite."}),"\n",(0,a.jsxs)(t.p,{children:["Test262 is the official ECMAScript Test Suite and exists to provide conformance tests for the latest drafts of the Ecma specification. It is used for all engines, you can even run it in your ",(0,a.jsx)(t.a,{href:"https://bakkot.github.io/test262-web-runner/",children:"browser"}),".",(0,a.jsx)(t.br,{}),"\n","Thanks to @Razican in v0.10 we now have a test harness that allows us to run it against Boa at any time."]}),"\n",(0,a.jsx)(t.p,{children:"This is a new crate inside the Boa repository that can parse through all of the tests (roughly 40,000 of them) in under 10 minutes and tell us how conformant we are."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:s(2165).A+"",width:"1216",height:"654"})}),"\n",(0,a.jsxs)(t.p,{children:["Today Boa has ",(0,a.jsx)("span",{class:"x x-first x-last",children:"18"}),"% conformity to the specification. We'll be keeping an eye on this number over the releases. We expect to achieve around 30% by 0.11 due to some of the fixes we're adding which should pass a few thousand tests."]}),"\n",(0,a.jsx)(t.p,{children:"These are run via Github Actions against PRs and for our main branch so that we can keep track of where we are and if there are regressions."}),"\n",(0,a.jsx)(t.h2,{id:"built-ins",children:"Built-ins"}),"\n",(0,a.jsxs)(t.p,{children:["We've added support for ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",children:(0,a.jsx)(t.code,{children:"Date"})}),", ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",children:(0,a.jsx)(t.code,{children:"Map"})})," and ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",children:"well-known symbols"}),". Supporting Well-known symbols unblocks a lot of work around adding ",(0,a.jsx)(t.code,{children:"@@iterators"})," to some of our global objects which is coming up in the next release.",(0,a.jsx)(t.br,{}),"\n","Both ",(0,a.jsx)(t.code,{children:"Math"})," and ",(0,a.jsx)(t.code,{children:"Number"})," have had their remaining methods implemented."]}),"\n",(0,a.jsx)(t.h2,{id:"lexer",children:"Lexer"}),"\n",(0,a.jsxs)(t.p,{children:["The lexer has been rebuilt from scratch. Just like the old parser it was a single file before looping through and becoming unmaintainable. Today we've reorganised it into separate modules which know how to lex certain areas. The new lexer ",(0,a.jsx)(t.a,{href:"https://github.com/boa-dev/boa/issues/294",children:"now supports goal symbols"})," and can now tokenize with the correct context at any time."]}),"\n",(0,a.jsx)(t.h3,{id:"goal-symbols",children:"Goal Symbols"}),"\n",(0,a.jsxs)(t.p,{children:["Our issue with goal symbols is explained by the V8 team ",(0,a.jsx)(t.a,{href:"https://v8.dev/blog/understanding-ecmascript-part-3#lexical-grammar",children:"here"})]}),"\n",(0,a.jsxs)(t.p,{children:["Previously we weren't distinguishing between the contexts where some input elements are permitted and some are not, so lexing ",(0,a.jsx)(t.code,{children:"/"})," would yeild a ",(0,a.jsx)(t.code,{children:"division"})," symbols when it should be a ",(0,a.jsx)(t.code,{children:"RegularExpressionLiteral"})," for example. This change unblocked us being able to run Test262."]}),"\n",(0,a.jsx)(t.p,{children:"Performance wise it is much faster for larger files. The lexer is far more efficient at streaming tokens to the parser than previously so in some scenarios we have big gains."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.em,{children:["You can see all the benchmarks ",(0,a.jsx)(t.a,{href:"https://boa-dev.github.io/boa/dev/bench/",children:"here"})]})}),"\n",(0,a.jsx)(t.h2,{id:"repl-syntax-highlighting",children:"Repl syntax highlighting"}),"\n",(0,a.jsxs)(t.p,{children:["Syntax highlighting was added to the repl this release thanks to @HalidOdat",(0,a.jsx)(t.br,{}),"\n","Our repl is made possible due to the great work of ",(0,a.jsx)(t.a,{href:"https://github.com/kkawakam/rustyline",children:"RustyLine"})]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"image",src:s(9204).A+"",width:"1507",height:"223"})}),"\n",(0,a.jsx)(t.h2,{id:"looking-forward",children:"Looking forward"}),"\n",(0,a.jsx)(t.p,{children:"There are plenty of fixes and performance changes still needed, we also hope to experiment with producing Bytecode from our AST in future. Test262 coverage will almost certainly increase, and we are polishing the public API for easier use when embedding into other Rust projects."}),"\n",(0,a.jsx)(t.p,{children:"Thanks to all those who contributed to 0.10, you can see the names in the full changelog linked above."}),"\n",(0,a.jsxs)(t.p,{children:["You can checkout Boa via ",(0,a.jsx)(t.a,{href:"https://github.com/boa-dev/boa",children:"Github"})," or on ",(0,a.jsx)(t.a,{href:"https://crates.io/crates/Boa",children:"crates.io"})]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},9204:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/syntaxHighlighting-15e6ee1c89ea7aa912f12feb0bed085a.gif"},2165:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/test262-screenshot-6dec809e4ab236a4655e0277075e639d.png"},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>r});var a=s(6540);const n={},o=a.createContext(n);function i(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);