"use strict";(self.webpackChunkboajs_dev=self.webpackChunkboajs_dev||[]).push([[1454],{9828:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>a});var i=t(4848),s=t(8453);const o={sidebar_position:3},c="Tracing Boa's Virtual Machine",d={id:"debugging/debug_trace",title:"Tracing Boa's Virtual Machine",description:'Please note: to run trace, boa needs to have the "trace" feature flag.',source:"@site/docs/debugging/debug_trace.md",sourceDirName:"debugging",slug:"/debugging/debug_trace",permalink:"/docs/debugging/debug_trace",draft:!1,unlisted:!1,editUrl:"https://github.com/boa-dev/boa-dev.github.io/tree/main/docs/docs/debugging/debug_trace.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"infoSidebar",previous:{title:"Debugging Tokens and AST nodes",permalink:"/docs/debugging/debug_tokens_ast"},next:{title:"VM Execution Flowgraph",permalink:"/docs/debugging/debug_flowgraph"}},r={},a=[{value:"Understanding Boa&#39;s Trace Output",id:"understanding-boas-trace-output",level:2},{value:"Comparing Trace Output",id:"comparing-trace-output",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"tracing-boas-virtual-machine",children:"Tracing Boa's Virtual Machine"}),"\n",(0,i.jsx)(n.p,{children:'Please note: to run trace, boa needs to have the "trace" feature flag.'}),"\n",(0,i.jsxs)(n.p,{children:["Once the AST has been generated, boa will compile it into bytecode, which is then executed by the VM.\nYou can print the bytecode and the executed instructions with the command-line flag ",(0,i.jsx)(n.code,{children:"--trace"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-boas-trace-output",children:"Understanding Boa's Trace Output"}),"\n",(0,i.jsx)(n.p,{children:'Once you have boa installed or setup with the "trace" feature flag, try some simple ECMAScript/JS in a test file.'}),"\n",(0,i.jsx)(n.p,{children:"Let's walkthrough an example of how to trace from a cloned boa repo."}),"\n",(0,i.jsx)(n.p,{children:'Add the below code into a "test.js" file in the project root.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:'title="test.js"',children:"//\nlet a = 1;\nlet b = 2;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then run the below command-line:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cargo run -- --test.js --trace\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Boa will now compile and run ",(0,i.jsx)(n.code,{children:"test.js"}),", which will output the below trace to ",(0,i.jsx)(n.code,{children:"stdout"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"----------------------Compiled Output: '<main>'-----------------------\nLocation  Count   Opcode                     Operands\n\n000001    0000    PushOne\n000006    0001    DefInitLet                 0000: 'a'\n000008    0002    PushInt8                   2\n000013    0003    DefInitLet                 0001: 'b'\n\nLiterals:\n    <empty>\n\nBindings:\n    0000: a\n    0001: b\n\nFunctions:\n    <empty>\n\n\n------------------------------------------ VM Start ------------------------------------------\nTime          Opcode                     Operands                   Top Of Stack\n\n386\u03bcs         PushOne                                               1\n6\u03bcs           DefInitLet                 0000: 'a'                  <empty>\n1\u03bcs           PushInt8                   2                          2\n2\u03bcs           DefInitLet                 0001: 'b'                  <empty>\n\nStack:\n    <empty>\n\n\nundefined\n"})}),"\n",(0,i.jsx)(n.p,{children:"The above output contains the following information:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The bytecode and properties of the function that will be executed","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Compiled Output"}),": The bytecode.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Location"}),": Location of the instruction (instructions are not the same size)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Count"}),": Instruction count."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Opcode"}),": Opcode name."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Operands"}),": The operands of the opcode."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Literals"}),": The literals used by the bytecode (like strings)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Bindings"}),": Binding names used by the bytecode."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Functions"}),": Function names use by the bytecode."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The code being executed (marked by ",(0,i.jsx)(n.code,{children:"Vm Start"})," or ",(0,i.jsx)(n.code,{children:"Call Frame"}),").","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Time"}),": The amount of time that instruction took to execute."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Opcode"}),": Opcode name."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Operands"}),": The operands of the opcode."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Top Of Stack"}),": The top element of the stack ",(0,i.jsx)(n.strong,{children:"after"})," execution of instruction."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Stack"}),": The trace of the stack after execution ends."]}),"\n",(0,i.jsxs)(n.li,{children:["The result of the execution (The top element of the stack, if the stack is empty then ",(0,i.jsx)(n.code,{children:"undefined"})," is returned)."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"comparing-trace-output",children:"Comparing Trace Output"}),"\n",(0,i.jsxs)(n.p,{children:["If you wanted another engine's bytecode output for the same JS, SpiderMonkey's bytecode output is the best to use. You can follow the setup ",(0,i.jsx)(n.a,{href:"https://udn.realityripple.com/docs/Mozilla/Projects/SpiderMonkey/Introduction_to_the_JavaScript_shell",children:"here"}),". You will need to build from source because the pre-built binarys don't include the debugging utilities which we need."]}),"\n",(0,i.jsxs)(n.p,{children:["NOTE: The binary was renamed as ",(0,i.jsx)(n.code,{children:"js_shell"})," due to ",(0,i.jsx)(n.code,{children:"js"})," conflicting with NodeJS."]}),"\n",(0,i.jsxs)(n.p,{children:["Once up and running you should be able to use ",(0,i.jsx)(n.code,{children:"js_shell -f tests/js/test.js"}),". You will get no output to begin with, this is because you need to run ",(0,i.jsx)(n.code,{children:"dis()"})," or ",(0,i.jsx)(n.code,{children:"dis([func])"})," in the code. Once you've done that you should get some output like so:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'loc     op\n-----   --\n00000:  GlobalOrEvalDeclInstantiation 0 #\nmain:\n00005:  One                             # 1\n00006:  InitGLexical "a"                # 1\n00011:  Pop                             #\n00012:  Int8 2                          # 2\n00014:  InitGLexical "b"                # 2\n00019:  Pop                             #\n00020:  GetGName "dis"                  # dis\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>d});var i=t(6540);const s={},o=i.createContext(s);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);